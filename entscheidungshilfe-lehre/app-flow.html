<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Entscheidungshilfe: FLOW</title>
    <meta charset="utf-8" />
    <meta http-equiv="content-language" content="de">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    <link rel="stylesheet" href="assets/css/eb.css" />
    <link rel="stylesheet" href="assets/css/eb_app.css" />
    <script src="assets/js/jquery.min.js"></script>
</head>
<style>
body {
    background: white;
    }
.qCont {
    background: var(--backgroundLightBlue);
            background: linear-gradient(90deg, rgba(18, 161, 154, 0.5) 0%, rgba(15, 113, 184, 0.5) 100%)
}
#selectAtLeastOne {
    background: rgba(18, 161, 154, 0);
    transition: all 2s ease;
    border-radius: 0.5em;
    padding: 0.2em;
}
</style>
<body class="is-preload" lang="de">
<div style="width: 100%; height: 50em; overflow:scroll">
    <h3>Entscheidungshilfe Lehre: Testversion mit Score-Anzeige</h3>
    <div id="qWrapper">
        <script>
            $("#qWrapper").load("app.html #questions", ()=>{
                document.querySelector("#credits").style.display="none"
                loadQuestions()
            })
        </script>
    </div>  
</div>
<h3>Szenarien und Scores</h3>
    <p>Filter: <input id="queryField" type="text"></input><button onclick="updateQuery()">Anwenden</button></p>
    <div id="scenarios" class="sCont"></div>
<script src="assets/js/jquery.csv.js"></script>
<script>
    var qCot, maxShownAnswers, sCont, all_data, questionInfo, all_scenarios, all_texts, infoTimeout, infoTimeout2, activeQ, activeA, nextQuestionIdx, scenarios, answers, activeScenarios, recent, topResults, questionOrder, progressBar, whichPart, group1start, group2start, group3start, group4start, leistungenQuestion, situationsQuestion, interactionsQuestion, pButton, nButton, sButton
    var query = ""
    function updateQuery(){
        query = document.querySelector("#queryField").value
        listActiveScenarios(activeScenarios)
    }

    function loadQuestions(){
        qCont = document.getElementById("questions")
        maxShownAnswers = 4

        sCont = document.getElementById("scenarios")

        nextQuestionIdx = 1

        scenarios = {}
        answers = {}
        activeScenarios = {}
        recent = []
        topResults

        questionOrder = [ 
            "TEXT_welcome",
            // 'TEXT_intro',
            // 'TEXT_group1',
            'artLV', 
            'TEXT_labore',
            // 'anzahlVL', 
            // 'anzahlSE',
            'interactions',
            'leistungen',
            'TEXT_group2',
            "niveauSt",
            "limZPSt",
            'nieSync',
            'niePr',
            "TEXT_group3",
            'regAbw',
            "onlBereit", 
            "TEXT_group4",
            "situations",
            'gaeste', 
        ]   

        // make progress bar
        progressBar = document.getElementById("progressBar")

        for (i=0; i<questionOrder.length+1; i++){
            let bit = document.createElement("div"); progressBar.append(bit)
            bit.classList.add("bit")
            bit.setAttribute("id", "prog_"+ i)
        }

        whichPart = document.querySelector("#whichPart")

        group1start = questionOrder.indexOf("TEXT_group1")
        group2start = questionOrder.indexOf("TEXT_group2")
        group3start = questionOrder.indexOf("TEXT_group3")
        group4start = questionOrder.indexOf("TEXT_group4")

        
        // Previous Question, Next Question, Submit buttons (will be moved around)
        pButton = document.createElement("button"); document.body.append(pButton)
        pButton.classList.add("prevButton", "asIcon")
        pButton.setAttribute("id", "prevButton")
        // pButton.innerHTML = "Vorherige Frage"
        pButton.addEventListener("click", function(){
            undoAnswer()
        })
        pButton.style.display = "none"

        nButton = document.createElement("button"); document.body.append(nButton)
        nButton.classList.add("nextButton", "asIcon")
        nButton.setAttribute("id", "nextButton")
        // nButton.innerHTML = "NÃ¤chste Frage"
        nButton.addEventListener("click", function(){
            if (activeQ.includes("TEXT_")){
                proceedFromQuestion()
            } else {
                if (activeQ != "situations" && activeQ != "leistungen"){
                    if (activeQ == "interactions"){
                        submitSingleAnswer(qq="intSync", aa=answers["intSync"], proceed=false)
                        // this doesn't do anything but proceed
                        submitSingleAnswer(qq = "interactions", aa="inputs", proceed=true, resetRecent=false)
                    } else {
                        submitSingleAnswer()
                    }
                } else {
                    answersToSubmit = {}
                    Object.keys(questionInfo[activeQ]["antworten"]).forEach((a, idx, array)=>{
                        answersToSubmit[a] = answers[a]
                        if (idx === array.length -1 ){
                            if (activeQ == "leistungen"){
                                // special case: if none of the tasks are selected, set keineLeistungen=ja in order to apply some effects
                                answersToSubmit["keineLeistungen"] = answers["keineLeistungen"]
                            }
                            console.log(answersToSubmit)
                            submitMultipleAnswers(answersToSubmit, activeQ)
                        }
                    })
                }
            }


        })
        nButton.style.display = "none"

        sButton = document.createElement("button"); document.body.append(sButton)
        sButton.classList.add("submitButton")
        sButton.setAttribute("id", "submitButton")
        sButton.innerHTML = "Absenden"
        sButton.addEventListener("click", function(){
            submitSingleAnswer()
            sessionStorage.setItem("answers", JSON.stringify(answers))
            getResult(activeScenarios)
        })
        sButton.style.display = "none"

        $.getJSON("data.json", function(json){
            all_data = json
            questionInfo = json['questions']
            situationsQuestion = questionInfo["situations"]
            leistungenQuestion = questionInfo["leistungen"]
            interactionsQuestion = questionInfo["interactions"]
            all_scenarios = json['scenarios']
            Object.entries(all_scenarios).forEach((s)=>{
                activeScenarios[s[0]] = 0
            })
            document.querySelector("#start").style.display = "block"
            
            // read texts_tips_matrix to get scenario titles
            $.get( "texts_tips_matrix.csv", function(CSVdata) {
            let csvData = $.csv.toObjects(CSVdata, {separator:';'});
            all_texts = {}
            csvData.forEach(function(dict){
                let key = dict["wert"]
                delete dict["wert"]
                all_texts[key] = Object.fromEntries(Object.entries(dict).filter(([k,v])=>!k.includes("text")))
                all_texts[key]["name"] = dict["name"]
            })        
            });
            setTimeout(()=>{
                listActiveScenarios(activeScenarios)
            }, 100)
            // start()
        })
    }
    function start(){
        document.querySelector("#DIV_TEXT_welcome").classList.add("past")
        setTimeout(()=>{
            document.querySelector("#DIV_TEXT_welcome").style.display="none"
        }, 800)
        displayQuestion(questionOrder[nextQuestionIdx], from='upcoming')
    }

    function hideQuestion(qKey){
        // hiding question container when next question arrives
        let qToHide = document.getElementById("DIV_" + qKey)
        qToHide.classList.remove("upcoming")
        qToHide.classList.add("past")
        if (qKey.includes("TEXT_")){
            // remove buttonContainer, otherwise it will keep getting added!
            setTimeout(()=>{
                qToHide.querySelector(".buttonContainer").remove()
            }, 500)
        }
        // qToHide.style.display = "none"
    }
    function showHideContext(th){
        let a = th.parentElement
        if (a.classList.contains("open")){
            a.classList.remove("open")
            a.querySelector(".contextContent").style.height = "0px"
            a.querySelector(".contextContent").style.visibility="hidden"
        } else {
            a.classList.add("open")
            a.querySelector(".contextContent").style.height = a.querySelector(".contextContent").scrollHeight + "px"
            a.querySelector(".contextContent").style.visibility="visible"
        }
    }
    function displayQuestion(qKey, from="upcoming"){
        let q, qText, qDiv

        activeQ = qKey
        activeA = null

        if (qKey.includes("TEXT_")){
            // if the panel is just a text block, just display its content
            qDiv = document.getElementById("DIV_" + qKey)
            qDiv.style.display='block'

            // change indicator of parts 1-4
            if (qDiv.querySelector(".sectionTitle")){
                let blockTitle = qDiv.querySelector(".sectionTitle").innerHTML
                let sectionNo = blockTitle.split("Teil ")[1].split(":")[0]
                let blockTitleAdj = blockTitle.split(": ")[1]
                whichPart.innerHTML = blockTitleAdj + " (" + sectionNo + "/4)" 
            }

        }
        else {
            // if the panel contains a question, display the question, its answers, and any additional info
            q = questionInfo[qKey]
            qText = q.text
            qDiv = document.createElement("div"); qCont.append(qDiv)
            qDiv.setAttribute("id", "DIV_" + qKey)
            if (from != "start"){
                qDiv.classList.add("qDiv", from)
            } else {
                qDiv.classList.add("qDiv")
            }
            
            let qP = document.createElement("p"); qDiv.append(qP)
            qP.setAttribute("id", "Q_" + qKey); qP.classList.add("qText")
            qP.innerHTML = qText
            
            //adding context
            if (q.addInfo){
                if (qKey == "situations" ||  qKey == "leistungen" || qKey == "interactions"){
                    let context = document.createElement("div"); context.classList.add("context"); qDiv.append(context)
                    context.innerHTML = "<p>*<em>" + questionInfo[qKey]["addInfo"] + "</em></p>"
                } else {
                    let context = document.createElement("div"); context.classList.add("context"); qDiv.append(context)
                    let contextHeader = document.createElement("h5"); context.append(contextHeader)
                    contextHeader.innerHTML = "<img src='images/fwd3.svg' alt=''/><span>Warum fragen wir das?</span>"
                    let contextContent = document.createElement("div"); contextContent.innerHTML="<ul></ul>"; context.append(contextContent)
                    contextContent.classList.add("contextContent")
                    for (var i = 0; i < q.addInfo.length; i++){
                        let ul = contextContent.querySelector("ul")
                        let infoText = q.addInfo[i]
                        let info // will be either p or ul > li
                        // IMPORTANT: currently you can only a single list of statements + optionally a single paragraph statement above them
                        if (infoText.includes("{NO BULLET}")){
                            info = document.createElement('p'); info.innerHTML = infoText.split("{NO BULLET}")[1]; contextContent.insertBefore(info,ul)
                        } else {
                            info = document.createElement('li'); info.innerHTML = infoText; ul.append(info)
                        }
                        
                        // if there are any sources, find them on the list of sources and link them
                        info.querySelectorAll("a").forEach((a)=>{
                            let target = a.getAttribute("href")
                            let source = document.querySelector(target)
                            let parent = source.parentNode
                            a.innerHTML = Array.prototype.indexOf.call(parent.children, source)+1
                        })
                    }
                    contextHeader.setAttribute("onclick", "showHideContext(this)")
                    }

            }

            if (qKey == "situations" || qKey == "leistungen" || qKey == "interactions"){
                // make all answers 'no' by default - they will be changed if someone checks the box
                Object.keys(questionInfo[qKey]["antworten"]).forEach((a)=>{
                    answers[a] = "nein"
                })
                if (qKey=="leistungen"){
                    answers["keineLeistungen"] = "ja"
                }
            }

            // add all answers to the question
            Object.entries(q.antworten).forEach((a, idx, array)=>{
                let aKey = a[0]
                let aText = a[1].text
                let aEffects = a[1].effects
                let aConditionalEffects= a[1].conditionalEffects

                let aDiv = document.createElement("div"); qDiv.append(aDiv)
                aDiv.setAttribute("id", "A_" + aKey)
                aDiv.classList.add("aDiv")
                let aRadio = document.createElement("input")

                // for checkbox question, create checkboxes, otherwise radio buttons
                if (qKey == "situations" || qKey == "leistungen" || qKey == "interactions"){
                    aRadio.setAttribute("type", "checkbox")  
                } else {
                    aRadio.setAttribute("type", "radio")
                }
                aRadio.setAttribute("name", "Q_" + qKey)
                aRadio.setAttribute("id", "Q_" + qKey + "_A_" + aKey)
                aRadio.setAttribute("value", aKey)
                aRadio.addEventListener("click", function(){  
                    selectAnswer(qKey, aKey)
                })
                let aLabel = document.createElement("label")
                aLabel.setAttribute("for", "Q_" + qKey + "_A_" + aKey)
                aLabel.innerHTML = aText

                aDiv.append(aRadio, aLabel)

                // Exceptions: Answers to not display
                    // hide formats that are not ready yet
                if (aKey =="SO"){
                    aDiv.style.display = "none"
                }
                    // hide least interaktive Option for Seminars
                if (qKey == "intSync" && aKey == "0" && answers["artLV"]=="SE"){
                    aDiv.style.display = "none"
                }
                    // hide "geringe RaumkapazitÃ¤t" for Vorlesungen
                if (qKey == "situations" && aKey == "begrAnz" && answers["artLV"]!="SE"){
                    aDiv.style.display = "none"
                }    

                // AT THE END OF THE LOOP: For checkbox questions, add "none of the above" as the last answer and highlight it
                if (qKey == "situations" || qKey == "leistungen"){ 
                    if (idx === array.length -1){
                        let aDiv = document.createElement("div"); qDiv.append(aDiv)
                        aDiv.setAttribute("id", "A_none")
                        aDiv.classList.add("aDiv","highlighted")
                        let aRadio = document.createElement("input")
                        aRadio.setAttribute("type", "checkbox")
                        
                        aRadio.setAttribute("name", "Q_" + qKey)
                        aRadio.setAttribute("id", "Q_" + qKey + "_A_none")
                        aRadio.setAttribute("value", "none")
                        aRadio.addEventListener("click", function(){  
                            selectAnswer(qKey, "none")
                        })
                        let aLabel = document.createElement("label")
                        aLabel.setAttribute("for", "Q_" + qKey + "_A_none")
                        aLabel.innerHTML = qKey == "situations" ? "Keine der genannten Situationen" : "keine der vorgenannten Leistungen"

                        aDiv.append(aRadio, aLabel)
                    } 
                } 
            })
            

        }

        if (true){
            let buttonContainer = document.createElement("div")
            buttonContainer.classList.add("buttonContainer")
            qDiv.append(buttonContainer)
            if (qKey == "TEXT_welcome"){
                buttonContainer.style.display = "none"
            }
            buttonContainer.append(pButton)
            buttonContainer.append(nButton)
            nButton.disabled = qKey=="situations" ||qKey=="leistungen" || qKey.includes("TEXT_") && qKey != "TEXT_labore" ? false : true
            pButton.style.display = nextQuestionIdx == 0 || qKey == "TEXT_welcome" ? "none" : "inline"
            nButton.style.display = nextQuestionIdx == 0 ? "none" : qKey == "TEXT_labore" ? "none" : "inline"

            // progress bar: check where we are!
            let progress = questionOrder.indexOf(activeQ)
            for (i=0; i< questionOrder.length; i++){
                if (i<=progress){
                    document.querySelector("#prog_" + i).classList.add("full")
                } else {
                    document.querySelector("#prog_" + i).classList.remove("full")
                }

            }
            // // text on upper left corner
            whichPart.parentElement.removeChild(whichPart)
            qDiv.append(whichPart)
            if (!qKey.includes("TEXT_")){
                whichPart.classList.add("show")
            } else {
                whichPart.classList.remove("show")
            }

            // add either to the bottom or to the top right
            if (qKey.includes("TEXT_")){
                if (qKey == "TEXT_labore" || qKey == "TEXT_welcome"){
                    progressBar.style.opacity=0
                } else {
                    progressBar.style.opacity=1
                }
                
                // progressBar.classList.remove("discreet")
                buttonContainer.append(progressBar)
            } else {
                progressBar.style.opacity=1
                // progressBar.classList.add("discreet")
                // qDiv.append(progressBar)
                buttonContainer.append(progressBar)
            }
            

        }

        setTimeout(function(){
            qDiv.classList.remove("upcoming", "past")
        }, 100)
        
        nextQuestionIdx += 1
    }

    function openInfoContainer(qKey){
        infoTimeout = setTimeout(()=>{
            document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.remove("closed")
            document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.add("opened")
            setTimeout(()=>{
                document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer > .infoText").classList.add("opened")
            }, 400)   
        }, 200)
    }

    function closeInfoContainer(qKey){
        clearTimeout(infoTimeout); clearTimeout(infoTimeout2)
        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer > .infoText").classList.remove("opened")
        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.remove("opened")
        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.add("closed")  
    }

    function selectAnswer(qKey, aKey){
        if (qKey == "situations" || qKey == "leistungen" || qKey == "interactions"){
            let aDiv = document.querySelector("#DIV_" + qKey + " > #A_" + aKey)
            if (aDiv.classList.contains("highlighted")){
                aDiv.classList.remove("highlighted")
            } else {
                aDiv.classList.add("highlighted")
            }

        } else {
            // formatting
            document.querySelectorAll("#DIV_" + qKey + " > .aDiv").forEach(function(aDiv){
                aDiv.classList.remove("highlighted")
            })
            document.querySelector("#DIV_" + qKey + " > #A_" + aKey).classList.add("highlighted")
            
        }
        
        // store the answer temporarily (before hitting "next")
        if (qKey!= "situations" && qKey != "leistungen"){
            if (qKey == "interactions"){
                // special case: interactions
                let checked = document.querySelector("#Q_" + qKey + "_A_"+aKey).checked
                // case 1: the option was previously unselected and is being selected
                // case 2: the option was previously selected and is being deselected
                answers[aKey] = checked ? "ja" : "nein"
                // check if there are any options left selected, otherwise prevent deselection
                if (document.querySelectorAll("#DIV_" + qKey + " > .highlighted").length == 0){
                    document.querySelector("#Q_" + qKey + "_A_"+aKey).checked = true
                    setTimeout(()=>{
                        document.querySelector("#DIV_" + qKey + " > #A_" + aKey).classList.add("highlighted")
                    }, 100)
                    document.querySelector("#selectAtLeastOne").style.background = "rgba(117, 208, 131, 0.2)"
                    setTimeout(()=>{
                        document.querySelector("#selectAtLeastOne").style.background = "rgba(18, 161, 154, 0)"
                    }, 2100)
                    answers[aKey] = "ja"
                }
                // update "intSync" answer based on what is checked: 
                let gruppen = answers["gruppen"] == "ja"
                let plenum = answers["plenum"] == "ja"
                answers["intSync"] = gruppen ? "2" : plenum ? "1" : "0"
            } else {
                answers[qKey] = aKey 
            }
        } else {
            // special treatment for checkbox questions
            if (aKey != "none"){
                // normal behavior:
                let checked = document.querySelector("#Q_" + qKey + "_A_"+aKey).checked
                // case 1: the option was previously unselected and is being selected
                // case 2: the option was previously selected and is being deselected
                answers[aKey] = checked ? "ja" : "nein"
                // check if there are any options left selected, otherwise highlight 'none of the above'
                if (document.querySelectorAll("#DIV_" + qKey + " > .highlighted").length == 0){
                    document.querySelector("#DIV_" + qKey + " > #A_none").classList.add("highlighted")
                    if (qKey=="leistungen"){
                        answers["keineLeistungen"] = "ja"
                    }
                    
                } else {
                    // if other options are selected, deselect 'none of the above' option
                    document.querySelector("#DIV_" + qKey + " > #A_none").classList.remove("highlighted")
                    if (qKey=="leistungen"){
                        answers["keineLeistungen"] = "nein"
                    }
                }


            } else {
                // clicking on "none of the above" cancels everything else
                Object.keys(questionInfo[qKey]["antworten"]).forEach((a)=>{
                    document.querySelector("#DIV_" + qKey + " > #A_" + a).classList.remove("highlighted")
                    answers[a] = "nein"
                })
            }
            
        }
        
        // check if there would be a next question if this answer is selected; if so, enable the "Next Button"
        let includeNextQuestion = false
        let dummyIdx = nextQuestionIdx
        if (dummyIdx >= questionOrder.length){
            document.querySelector("#DIV_" + activeQ + " > .buttonContainer").append(sButton)
            sButton.style.display="inline"
            progressBar.style.opacity=0
            }
        while (dummyIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[dummyIdx]
            
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                if (sButton.style.display == "inline"){
                    document.body.appendChild(sButton)
                    sButton.style.display="none"
                }
                nButton.disabled = false
                break
            } else {
                dummyIdx += 1
            }
            // if we reach the end and don't find a valid question, display final submit button
            if (dummyIdx >= questionOrder.length){
                document.querySelector("#DIV_" + activeQ + " > .buttonContainer").append(sButton)
                sButton.style.display="inline"
                progressBar.style.opacity=0
            }
        }

        activeA = aKey
    }

    function proceedFromQuestion(cq=null){
        let cKey = cq? cq : activeQ
        // check if there is another question left to display and, if yes, do so.
        let includeNextQuestion = false
        while (nextQuestionIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[nextQuestionIdx]
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                hideQuestion(cKey)
                displayQuestion(nextQuestion, from="upcoming")
                break
            } else {
                nextQuestionIdx += 1
            }
        }
    }
    function submitSingleAnswer(qq=null, aa=null, proceed=true, resetRecent=true){
        let qKey = qq? qq : activeQ
        console.log(qq,  aa)
        let pKey = qKey
        let aKey = aa? aa : activeA
        
        if (resetRecent){
            recent = []
        }
        
        if (proceed){
            let allRadios = document.getElementById("DIV_" + qKey).querySelectorAll("input")
            for (let radio of allRadios){
                if (radio.id == "Q_" + qKey + "_A_" + aKey){
                    radio.classList.add("selected")   
                }
                radio.setAttribute("disabled", true)
            }
        }

        let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
        let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]

        Object.entries(effects).forEach((entry)=>{
            if (Object.keys(activeScenarios).includes(entry[0])){ //  && entry[1] != "FUNC"){
                let scoreVal = +(activeScenarios[entry[0]])
                newScoreVal = scoreVal + entry[1]
                activeScenarios[entry[0]] = newScoreVal
                recent.push(entry[0])
                // console.log("APPLIED EFFECT,", entry[0], qKey)
            }
        })

        Object.entries(conditionalEffects).forEach((entry)=>{
            let sKey = entry[0]
            let sEffects = entry[1]
        
            Object.entries(sEffects).forEach((sEntry)=>{
                let conditions = sEntry[0]
                let score = sEntry[1]
                // separate conditions if more than one
                let met = andCheck(conditions)
                if (met){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal + score
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(sKey)
                    // console.log("APPLIED CONDITIONAL EFFECT,", entry[0], qKey)
                }
            })
            
        })

        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)

        if (proceed){
            proceedFromQuestion(pKey)
        }
    
    }
    function submitMultipleAnswers(answersToSubmit, parentQ){
        Object.entries(answersToSubmit).forEach((aEntry, idx, array)=>{
            submitSingleAnswer(aEntry[0], aEntry[1], proceed=false, resetRecent=idx==0)
            if (idx === array.length -1){
                submitSingleAnswer(parentQ, array[idx-1][0], proceed=true, resetRecent=false)
            } 
            
        })
        // // the following "submission" does nothing but advance to the next question
        // submitSingleAnswer("situations", "intKoll", proceed=true)
    }

    function undoAnswer(){
        // remove current question, unless it's just a text box
        let cQ = document.getElementById("DIV_" + activeQ)
        cQ.classList.add("upcoming")
        if (!activeQ.includes("TEXT_")){
            setTimeout(function(){
            cQ.remove()
        }, 500)
        } else {
            setTimeout(function(){
            cQ.querySelector(".buttonContainer").remove()
        }, 500)
        }

        
        // if user has already selected an answer for the current question and not submitted it:
        // remove the current answer from 'answers' before proceeding
        // note: this doesn't have any effect if the 'question' was just a textbox
        if (activeA){
            if (activeQ && activeQ != "situations"){
                delete answers[activeQ]
            }            
        }
        // for situationsQuestion: delete answer regardless
        if (activeQ == "situations"){
            Object.keys(situationsQuestion["antworten"]).forEach((key)=>{
                delete answers[key]
            })            
        }
        // for interactions question: delete intSync answer
        if (activeQ == "interactions"){
            Object.keys(interactionsQuestion["antworten"]).forEach((key)=>{
                delete answers[key]
            })            
            delete answers["intSync"]
        }

        // get information about the last answered question and change variable activeQ
        if (activeQ == "situations"){
            activeQ = questionOrder[questionOrder.indexOf("situations")-1]
        } else {
            if (Object.keys(situationsQuestion["antworten"]).includes(Object.keys(answers)[Object.keys(answers).length-1])){
                activeQ = "situations"
            } else {
                // note: this works whether we are returning to a textbox or an actual question
                let oneBefore = questionOrder[questionOrder.indexOf(activeQ)-1]
                // oneBefore = Object.keys(answers)[Object.keys(answers).length-1] //this wouldn't work for text boxes, since they don't give answers

                // cases where a previous question/block must be skipped
                if ( oneBefore == "TEXT_labore"){
                    // 1. text about labs coming soon
                    activeQ = "artLV"
                } else if (oneBefore == "anzahlVL" && !answers["anzahlVL"]) {
                    // 2. question anzahlVL if Seminar had been chosen
                    activeQ = "artLV"
                } else if (oneBefore == "anzahlSE" && !answers["anzahlSE"]) {
                    // 3. question anzahlSE if Vorlesung had been chosen
                    activeQ = "anzahlVL"
                } else if (oneBefore == "nieSync" && !answers["nieSync"]){
                    // 4. question nieSync if it should have been skipped
                    activeQ = "limZPSt"
                } else if (oneBefore == "niePr" && !answers["niePr"]){
                    // 5. question niePr if it should have been skipped
                    if (!answers["nieSync"]){
                        // 6. maybe both nieSync and niePr were skipped
                        activeQ = "limZPSt"
                    } else {
                        activeQ = "nieSync"
                    }
                } else {
                    // default
                    activeQ = oneBefore
                }                

            }
        }
        
        nextQuestionIdx = questionOrder.indexOf(activeQ)

        activeA = null
        let lastAnswer = {}
        if (activeQ == "situations"  || activeQ == "leistungen"){
            Object.keys(questionInfo[activeQ]["antworten"]).forEach((key)=>{
                lastAnswer[key] = answers[key]
            })    
        } else {
            if (activeQ == "interactions"){
                lastAnswer["intSync"] = answers["intSync"]
            } else {
                lastAnswer[activeQ] = answers[activeQ]  
            }
        }

        
        // delete the stored answers of the last answered question
        delete answers[activeQ]
        if (activeQ == "situations" || activeQ == "leistungen" || activeQ == "interactions"){
            Object.keys(questionInfo[activeQ]["antworten"]).forEach((key)=>{
                delete answers[key]
            })
            if (activeQ == "interactions"){
                delete answers["intSync"]
            }     
        }

        function undoAllEffects(qKey, aKey){
            console.log(qKey, aKey)
            recent = []
            // calculate score provided by last answer for each code (but this time subtract it!)
            let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
            let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]

            Object.entries(effects).forEach((entry)=>{
                if (Object.keys(activeScenarios).includes(entry[0])){ // && entry[1] != "FUNC"){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal - entry[1]
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(entry[0])
                    // console.log("REVERSED EFFECT,", entry[0], qKey)
                }
            })

            Object.entries(conditionalEffects).forEach((entry)=>{
                let sKey = entry[0]
                let sEffects = entry[1]
                Object.entries(sEffects).forEach((sEntry)=>{
                    let conditions = sEntry[0]
                    let score = sEntry[1]
                    
                    // separate conditions if more than one
                    let met = andCheck(conditions)
                    if (met){
                        let scoreVal = +(activeScenarios[entry[0]])
                        newScoreVal = scoreVal - score
                        activeScenarios[entry[0]] = newScoreVal
                        recent.push(sKey)
                        // console.log("REVERSED CONDITIONAL EFFECT,", entry[0], qKey)
                    }
                })
            })
        }

        if (!activeQ.includes("TEXT_")){
            console.log(lastAnswer)
            Object.entries(lastAnswer).forEach((response)=>{
            qKey = response[0]
            aKey = response[1]
            undoAllEffects(qKey, aKey)
        })
        }

        // let qKey = activeQ
        // let aKey = lastAnswer

        // remove previous question and display it again
        if (activeQ.includes("TEXT_")){
            document.getElementById("DIV_" + activeQ).style.display="none"
        }
        else {
            document.getElementById("DIV_" + activeQ).remove()
        }
        displayQuestion(activeQ, from="past")

        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)

    }

    // shows live-scores below tool for testing purposes
    function listActiveScenarios(sObju){
        sObj = Object.entries(sObju).sort(([,a],[,b]) => b-a).reduce((r, [k, v]) => ({ ...r, [k]: v }), {});
        sCont.innerHTML = ""
        Object.entries(sObj).forEach((entry)=>{
            sKey = entry[0]
            sVal = entry[1]
            if (query == "" || sKey.includes(query)){
                let tr = document.createElement("p")
                let name = document.createElement("span")
                name.classList.add("sName")
                let score = document.createElement("span")
                name.innerHTML = sKey
                let scenarioTitle = all_texts[sKey.slice(0,-6)].name
                name.setAttribute("title", scenarioTitle)
                score.innerHTML = sVal
                score.setAttribute("id", "SCORE_" + sKey)
                score.classList.add("score")
                tr.append(name, score)
                if (recent.includes(sKey)){
                    tr.classList.add("recent")
                }
                sCont.append(tr)
            }

        })

        for (let score of document.querySelectorAll(".score")){
            let value = +(score.innerHTML)
            if (value > 0){
                score.style.color = "#0e7700"
            } else if (value <0){
                score.style.color = "#d93300"
            } else {
                score.style.color = "#585858"
            }
        }
    }

    function getResult(finalResults){
        // decide which scenarios to show!
        topResults = getTopScenarios(finalResults)
        let firstResult = topResults[0]
        window.open("var_result.html?shownScenario=" + firstResult + "&topTier=" + JSON.stringify(topResults), "_self")
    }

    // Auxiliary funcitons (specialized)
    function getTopScenarios(results){
        shownScenarios = []
        // determine top 3 scores (multiple scenarios can have the same score)
        let firstScore = Math.max(...Object.values(results))
        let topTier = Object.entries(results).filter(([k,v])=>v==firstScore).reduce((r, [k,v])=>[...r,k], []) // returns list of scenarios
        topTier = sortByAsyncInt(topTier)

        let secondScore = Math.max(...Object.values(Object.entries(results).filter(([k,v])=>v<firstScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let secondTier = Object.entries(results).filter(([k,v])=>v==secondScore).reduce((r, [k,v])=>[...r,k], [])
        secondTier = sortByAsyncInt(secondTier)

        let thirdScore = Math.max(...Object.values(Object.entries(results).filter(([k,v])=>v<secondScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let thirdTier = Object.entries(results).filter(([k,v])=>v==thirdScore).reduce((r, [k,v])=>[...r,k], [])
        thirdTier = sortByAsyncInt(thirdTier)

        for (let i=0; i<(topTier.length + secondTier.length + thirdTier.length); i++){
            // first tier: include all non-duplicates
            if (i<topTier.length){
                let scenarioToAdd = topTier[i]
                // do not add scenarios with same format hyb, rem, ringonl, etc.
                if (notDuplicate(scenarioToAdd, shownScenarios)){
                    shownScenarios.push(scenarioToAdd)
                }

            } else {
                // second tier: don't consider if score less than zero
                if (i < (topTier.length+secondTier.length) && secondScore>=0){
                    let j = i - topTier.length
                    let scenarioToAdd = secondTier[j]
                    if (notDuplicate(scenarioToAdd, shownScenarios)){
                        shownScenarios.push(scenarioToAdd)
                    }

                } else {
                    // third tier: don't consider if score less than zero
                    if (thirdScore>=0){
                        let k = i - topTier.length - secondTier.length
                        let scenarioToAdd = thirdTier[k]
                        if (notDuplicate(scenarioToAdd, shownScenarios)){
                            shownScenarios.push(scenarioToAdd)
                        }
                    }

                    }
                }
            if (shownScenarios.length >=maxShownAnswers){
                break
            }     
            
        }
        return shownScenarios
    }

    // logic
    function includeCheck(qKey){
        // checks if a question should be displayed
        // assumes that questions have been ordered correctly, otherwise results may be unexpected
        if (qKey.includes("TEXT_")){
            
            let condition = (qKey == "TEXT_labore") ? "artLV=PR" : true
            if (condition == true){
                return true
            } else {
                return andCheck(condition)
            }
        } else {
            let condition = questionInfo[qKey]["condition"]
            if (condition == true){
                return true
            } else {
                return andCheck(condition)
            }
        }        
    }

    function andCheck(conditions){
        // checks if all conditions qKey=aKey are simultaneously true
        let i = 0
        while (i < 10){
            
            [qKey, aKey] = conditions.split("+")[i].split("=")
            if (qKey.includes("!")){
                // check if it's a NOT test
                qKeyR = qKey.split("!")[0]
                if (answers[qKeyR] == aKey || !answers[qKeyR]){
                    return false
                } else {
                    i += 1
                }
            } else {
                if (answers[qKey] != aKey){
                return false
                } else {
                    i += 1
                }
            }

            if (i >= conditions.split("+").length){
                return true
            }
        }
        conditions.split("+").forEach((condition, i)=>{
            [qKey, aKey] = condition.split("=")
            if (answers[qKey] != aKey){
                if (i <4){
                    realConditions[i] = false
                } else {
                    console.log("only up to 4 simultaneous conditions supported; the rest are ignored")
                }
            }
        })
        
    }
    
    function notDuplicate(newScenario, shownScenarios){
        sType = newScenario.split("-")[1]
        if (shownScenarios.map((str)=>str.split("-")[1]).includes(sType)){
            // if the type of scenario is the same, still include if there is asynchronous participation alternative for one scenario
            let matchingScenarios = shownScenarios.filter((str)=>str.split("-")[1] == sType)
            if (matchingScenarios.length > 1){
                // can't add same scenario a third time!
                return false
            }
            let matchingScenario = matchingScenarios[0]
            let asyncNew = newScenario.split("-")[3] // asynchronous participation mode of new scenario
            let asyncMatching = matchingScenario.split("-")[3] // asynchronous participation mode of matching scenario
            if ([asyncNew, asyncMatching].includes("3") && asyncNew != asyncMatching){
                return true
            } else {
                return false
            }
        } else {
            return true
        }
    }
    function sortByAsyncInt(arr){
        // Step 1: Group by prefix
        const grouped = {};

        arr.forEach(item => {
        const match = item.match(/^(.*?)-(\d+-\d+-\d+)$/);
        if (!match) return;

        const prefix = match[1];
        const digits = match[2];

        if (!grouped[prefix]) grouped[prefix] = [];
        grouped[prefix].push(digits);
        });

        // Step 2: Sort each group of digits
        Object.keys(grouped).forEach(prefix => {
        grouped[prefix].sort((b, a) => {
            const [a1, a2, a3] = a.split("-").map(Number);
            const [b1, b2, b3] = b.split("-").map(Number);

            if (a1 !== b1) return a1 - b1;
            if (a2 !== b2) return a2 - b2;
            return a3 - b3;
        });
        });

        // Step 3: Recombine into final array, keeping prefix order
        const final = [];
        Object.keys(grouped).forEach(prefix => {
        grouped[prefix].forEach(digits => {
            final.push(`${prefix}-${digits}`);
        });
        });
        return final
    }
</script>
</body>
</html>
