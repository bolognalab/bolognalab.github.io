<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>Entscheidungshilfe: FLOW</title>
    <meta charset="utf-8" />
    <meta http-equiv="content-language" content="de">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
    <noscript><link rel="stylesheet" href="assets/css/noscript.css" /></noscript>
    <link rel="stylesheet" href="assets/css/eb.css" />
    <link rel="stylesheet" href="assets/css/eb_app.css" />
    <script src="assets/js/jquery.min.js"></script>
</head>
<body class="is-preload" lang="de">
<div style="width: 100%">
    <h3>Entscheidungshilfe Lehre: Testversion mit Score-Anzeige</h3>
    <div id="questions" class="qCont" style="height: 45em">
        <img class="backgroundImage" src = "images/treeTemp.svg" />
        <div id="DIV_TEXT_welcome" class="qDiv">
            <p id="whichPart">:)</p>
            <h2 style="text-align: center"><img id="welcomeLogo" src="images/NHL_logo.svg" /></h2>
            <h1>Entscheidungshilfe Online und Hybride Lehre</h1>
            <p>Vor Ort, online, oder hybrid? Entdecken Sie, welches Format für Sie am besten passt! In den nächsten Schritten werden Sie aufgefordert, Gedanken über die folgenden Aspekten Ihrer Lehrveranstaltung zu machen:</p>
            <ul>
                <li>Wie wichtig ist <b>physische Präsenz und Synchronität</b>, damit jemand erfolgreich in Ihrem Kurs sein kann?</li>
                <li>Welche Anforderungen hat Ihre studentische Kohorte an <b>Strukturierung</b> und <b>Flexibilität?</b></li>
                <li>Inwieweit passt virtuelle Lehre zu Ihrem <b>Lehrstil</b> und zu den <b>Bedingungen Ihrer Hochschule?</b></li>
            </ul>
            <p style="margin-bottom: 1.5em">Als Ergebnis erhalten Sie - neben einem <b>empfohlenen Lehrformat</b> - Tipps für die <b>synchrone</b> und <b>asynchrone</b> Planung Ihres Kurses. Es ist okay, wenn Sie für die Beantwortung mancher Fragen nicht sicher sind! Es gibt immer die Möglichkeit, zurückzugehen und andere Antwortmöglichkeiten auszuprobieren.</p>
            <div class="buttonContainer start"><button id="start" class="submitButton" onclick="start()" style="display:none">Beginnen</button></div>
            <div id="useCase2Container"><p>oder...</p><a href='select.html'>Ich habe mich schon für ein Lehrformat entschieden und suche dafür didaktische und technische Tipps</a></div>
        </div>

        <div id="DIV_TEXT_group1" class="qDiv upcoming" style="display:none">
            <h2 style="text-align:center"><img src="images/descImg/se-praes.jpg" style="width: 300px"/></h2>
            <h2 class="sectionTitle">Teil 1: Art und Ziele der Lehrveranstaltung</h2>
            <p>In den ersten Fragen geht es um die Art des Kurses und der Lernziele, die die Studierenden am Ende des Semesters beherrschen sollen – diese grundlegenden Ziele liegen nämlich im Kern der Entscheidung über das Lehrformat.</p>
        </div>
        <div id="DIV_TEXT_group2" class="qDiv upcoming" style="display:none">
            <h2 style="text-align:center"><img src="images/descImg/se-hyb.jpg" style="width: 300px"/></h2>
            <h2 class="sectionTitle">Teil 2: Studentische Bedingungen und Teilnahme</h2>
            <p>Die folgenden Fragen sollen Ihnen helfen, die <b>Flexibilitäts- und Strukturierungsbedürfnisse der Studierenden</b> in Ihrer Lehrveranstaltung zu verstehen.</p>
            <p>Bei der Kursplanungsphase können Sie wahrscheinlich nicht alle Fragen zu Ihren zukünftigen Studierenden mit Sicherheit beantworten - das ist in Ordnung!</p>
            <p>Sie können die Fragen auf der Grundlage <b>vorheriger oder "typischer" studentischer Kohorten</b> (z.B. Semester im Studium, Berufsfeld) beantworten oder indem Sie reflektieren, auf welche möglichen Szenarien Sie vorbereitet sein wollen, um eine <b>möglichst barrierearme Teilnahme</b> zu ermöglichen.</p>
        </div>
        <div id="DIV_TEXT_group3" class="qDiv upcoming" style="display:none">
            <h2 style="text-align:center"><img src="images/descImg/se-onl.jpg" style="width: 300px"/></h2>
            <h2 class="sectionTitle">Teil 3: Teilnahme und Bedingungen der Lehrperson(en)</h2>
            <p>Kurz vor dem Ende des Entscheidungsprozesses kommen wir jetzt zum Thema Lehrende: Ebenso wie die Studierenden haben auch die Lehrenden individuelle Bedürfnisse in Bezug auf die Flexibilität und das Lehrformat!</p>
        </div>
        <div id="DIV_TEXT_group4" class="qDiv upcoming" style="display:none">
            <h2 style="text-align:center"><img src="images/descImg/vl-ringpraes.jpg" style="width: 300px"/></h2>
            <h2 class="sectionTitle">Teil 4: Zusätzliche Faktoren</h2>
            <p>Wir sind fast fertig! In den letzten paar Fragen prüfen wir, ob für Ihren Kurs bestimmte „Sonderbedingungen“ gelten.</p>
        </div>
        <div id="DIV_TEXT_labore" class="qDiv upcoming" style="display:none">
            <h2><em>Coming Soon: Hybride und virtuelle Laborkonzepte</em></h2>
            <p>Wir sind noch dabei, didaktische Empfehlungen für verschiedene Online- und hybride Laborveranstaltungen zu entwickeln! Bis dann schauen Sie sich gern die folgenden Beispiele von hybriden und virtuellen Laborkursen als Inspiration:</p>
            <ul>
                <li><a href="https://leko.service.th-nuernberg.de/portal-digitale-lehre/anleitungen/hybride-laborpraktika-mit-mobilem-setup/" aria-label="TH Nürnberg: Hybride Laborpraktika mit mobilem Setup">TH Nürnberg: Hybride Laborpraktika mit mobilem Setup</a></li>
                <li><a href="https://www.hs.mh.tum.de/exercisebiology/lehre-thesis/ilab/" aria-label="TU München: Projekt iLab (Laborvideos)">TU München: Projekt <em>iLab</em> (Laborvideos)</a></li>
            </ul>
        </div>
        <div id="progressBar" class="progressBar"></div>
    </div>
    <h3>Szenarien und Scores</h3>
    <div id="scenarios" class="sCont"></div>
    <div id="sources">
        <h5>Quellen</h5>
        <ol class="sources">
            <li id ="source_uniHamburgSozialeInteraktion"><a href='https://www.hul.uni-hamburg.de/selbstlernmaterialien/6-soziale-interaktion.html'>Uni Hamburg: Social Design - Soziale Interaktion</a></li>
            <li id ="source_moerthUFF21"><a href='https://www.youtube.com/watch?v=JkmYvK8j-zs'>M. Mörth, I. Ulrich, N. Enders: "Online, blended, hybrid, Präsenz?" - University:Future Festival 2021 (VideO)</a></li>
            <li id="source_studienwahl"><a href='https://studienwahl.de/themen-des-monats/jobben-neben-dem-studium'>Studienwahl.de: Jobben neben dem Studium (03.09.2024)</a></li>
        </ol> 
    </div>
    
   
</div>
<script src="assets/js/jquery.csv.js"></script>
<script>   
    const qCont = document.getElementById("questions")
    const maxShownAnswers = 4

    const sCont = document.getElementById("scenarios")

    var all_data, questionInfo, all_scenarios, all_texts, infoTimeout, infoTimeout2

    var activeQ, activeA
    var nextQuestionIdx = 1

    var scenarios = {}
    var answers = {}
    var activeScenarios = {}
    var recent = []
    var topResults

    const questionOrder = [ 
        "TEXT_welcome",
        // 'TEXT_intro',
        // 'TEXT_group1',
        'artLV', 
        'TEXT_labore',
        // 'anzahlVL', 
        // 'anzahlSE',
        'intSync',
        'leistungen',
        'TEXT_group2',
        "niveauSt",
        "limZPSt",
        'nieSync',
        'niePr',
        "TEXT_group3",
        'regAbw',
        "onlBereit", 
        "TEXT_group4",
        "situations",
        'gaeste', 
    ]   

    // make progress bar
    const progressBar = document.getElementById("progressBar")

    for (i=0; i<questionOrder.length+1; i++){
        let bit = document.createElement("div"); progressBar.append(bit)
        bit.classList.add("bit")
        bit.setAttribute("id", "prog_"+ i)
    }

    const whichPart = document.querySelector("#whichPart")

    const group1start = questionOrder.indexOf("TEXT_group1")
    const group2start = questionOrder.indexOf("TEXT_group2")
    const group3start = questionOrder.indexOf("TEXT_group3")
    const group4start = questionOrder.indexOf("TEXT_group4")

    var leistungenQuestion, situationsQuestion
    
    // Previous Question, Next Question, Submit buttons (will be moved around)
    var pButton = document.createElement("button"); document.body.append(pButton)
    pButton.classList.add("prevButton", "asIcon")
    pButton.setAttribute("id", "prevButton")
    // pButton.innerHTML = "Vorherige Frage"
    pButton.addEventListener("click", function(){
        undoAnswer()
    })
    pButton.style.display = "none"

    let nButton = document.createElement("button"); document.body.append(nButton)
    nButton.classList.add("nextButton", "asIcon")
    nButton.setAttribute("id", "nextButton")
    // nButton.innerHTML = "Nächste Frage"
    nButton.addEventListener("click", function(){
        if (activeQ.includes("TEXT_")){
            proceedFromQuestion()
        } else {
            if (activeQ != "situations" && activeQ != "leistungen"){
                submitSingleAnswer()
            } else {
                answersToSubmit = {}
                Object.keys(questionInfo[activeQ]["antworten"]).forEach((a, idx, array)=>{
                    answersToSubmit[a] = answers[a]
                    if (idx === array.length -1 ){
                        if (activeQ == "leistungen"){
                            // special case: if none of the tasks are selected, set keineLeistungen=ja in order to apply some effects
                            answersToSubmit["keineLeistungen"] = answers["keineLeistungen"]
                        }
                        console.log(answersToSubmit)
                        submitMultipleAnswers(answersToSubmit, activeQ)
                    }
                })
            }
        }


    })
    nButton.style.display = "none"

    let sButton = document.createElement("button"); document.body.append(sButton)
    sButton.classList.add("submitButton")
    sButton.setAttribute("id", "submitButton")
    sButton.innerHTML = "Absenden"
    sButton.addEventListener("click", function(){
        submitSingleAnswer()
        sessionStorage.setItem("answers", JSON.stringify(answers))
        getResult(activeScenarios)
    })
    sButton.style.display = "none"

    $.getJSON("data.json", function(json){
        all_data = json
        questionInfo = json['questions']
        situationsQuestion = questionInfo["situations"]
        leistungenQuestion = questionInfo["leistungen"]
        all_scenarios = json['scenarios']
        Object.entries(all_scenarios).forEach((s)=>{
            activeScenarios[s[0]] = 0
        })
        document.querySelector("#start").style.display = "block"
        
        // read texts_tips_matrix to get scenario titles
        $.get( "texts_tips_matrix.csv", function(CSVdata) {
        let csvData = $.csv.toObjects(CSVdata, {separator:';'});
        all_texts = {}
        csvData.forEach(function(dict){
            let key = dict["wert"]
            delete dict["wert"]
            all_texts[key] = Object.fromEntries(Object.entries(dict).filter(([k,v])=>!k.includes("text")))
            all_texts[key]["name"] = dict["name"]
        })        
        });
        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)
        // start()
    })

    function start(){
        document.querySelector("#DIV_TEXT_welcome").classList.add("past")
        setTimeout(()=>{
            document.querySelector("#DIV_TEXT_welcome").style.display="none"
        }, 800)
        displayQuestion(questionOrder[nextQuestionIdx], from='upcoming')
    }

    function hideQuestion(qKey){
        // hiding question container when next question arrives
        let qToHide = document.getElementById("DIV_" + qKey)
        qToHide.classList.remove("upcoming")
        qToHide.classList.add("past")
        if (qKey.includes("TEXT_")){
            // remove buttonContainer, otherwise it will keep getting added!
            setTimeout(()=>{
                qToHide.querySelector(".buttonContainer").remove()
            }, 500)
        }
        // qToHide.style.display = "none"
    }
    function showHideContext(th){
        let a = th.parentElement
        if (a.classList.contains("open")){
            a.classList.remove("open")
            a.querySelector(".contextContent").style.height = "0px"
            a.querySelector(".contextContent").style.visibility="hidden"
        } else {
            a.classList.add("open")
            a.querySelector(".contextContent").style.height = a.querySelector(".contextContent").scrollHeight + "px"
            a.querySelector(".contextContent").style.visibility="visible"
        }
    }
    function displayQuestion(qKey, from="upcoming"){
        let q, qText, qDiv

        activeQ = qKey
        activeA = null

        if (qKey.includes("TEXT_")){
            // if the panel is just a text block, just display its content
            qDiv = document.getElementById("DIV_" + qKey)
            qDiv.style.display='block'

            // change indicator of parts 1-4
            if (qDiv.querySelector(".sectionTitle")){
                let blockTitle = qDiv.querySelector(".sectionTitle").innerHTML
                let sectionNo = blockTitle.split("Teil ")[1].split(":")[0]
                let blockTitleAdj = blockTitle.split(": ")[1]
                whichPart.innerHTML = blockTitleAdj + " (" + sectionNo + "/4)" 
            }
  
        }
        else {
            // if the panel contains a question, display the question, its answers, and any additional info
            q = questionInfo[qKey]
            qText = q.text
            qDiv = document.createElement("div"); qCont.append(qDiv)
            qDiv.setAttribute("id", "DIV_" + qKey)
            if (from != "start"){
                qDiv.classList.add("qDiv", from)
            } else {
                qDiv.classList.add("qDiv")
            }
            
            let qP = document.createElement("p"); qDiv.append(qP)
            qP.setAttribute("id", "Q_" + qKey); qP.classList.add("qText")
            qP.innerHTML = qText
            
            //adding context
            if (q.addInfo){
                if (qKey == "situations" ||  qKey == "leistungen"){
                    let context = document.createElement("div"); context.classList.add("context"); qDiv.append(context)
                    context.innerHTML = "<p>*<em>" + questionInfo[qKey]["addInfo"] + "</em></p>"
                } else {
                    let context = document.createElement("div"); context.classList.add("context"); qDiv.append(context)
                    let contextHeader = document.createElement("h5"); context.append(contextHeader)
                    contextHeader.innerHTML = "<img src='images/fwd3.svg' alt=''/><span>Warum fragen wir das?</span>"
                    let contextContent = document.createElement("div"); contextContent.innerHTML="<ul></ul>"; context.append(contextContent)
                    contextContent.classList.add("contextContent")
                    for (var i = 0; i < q.addInfo.length; i++){
                        let ul = contextContent.querySelector("ul")
                        let infoText = q.addInfo[i]
                        let info // will be either p or ul > li
                        // IMPORTANT: currently you can only a single list of statements + optionally a single paragraph statement above them
                        if (infoText.includes("{NO BULLET}")){
                            info = document.createElement('p'); info.innerHTML = infoText.split("{NO BULLET}")[1]; contextContent.insertBefore(info,ul)
                        } else {
                            info = document.createElement('li'); info.innerHTML = infoText; ul.append(info)
                        }
                        
                        // if there are any sources, find them on the list of sources and link them
                        info.querySelectorAll("a").forEach((a)=>{
                            let target = a.getAttribute("href")
                            let source = document.querySelector(target)
                            let parent = source.parentNode
                            a.innerHTML = Array.prototype.indexOf.call(parent.children, source)+1
                        })
                    }
                    contextHeader.setAttribute("onclick", "showHideContext(this)")
                    }

            }

            if (qKey == "situations" || qKey == "leistungen"){
                // make all answers 'no' by default - they will be changed if someone checks the box
                Object.keys(questionInfo[qKey]["antworten"]).forEach((a)=>{
                    answers[a] = "nein"
                })
                if (qKey=="leistungen"){
                    answers["keineLeistungen"] = "ja"
                }
            }

            // add all answers to the question
            Object.entries(q.antworten).forEach((a, idx, array)=>{
                let aKey = a[0]
                let aText = a[1].text
                let aEffects = a[1].effects
                let aConditionalEffects= a[1].conditionalEffects

                let aDiv = document.createElement("div"); qDiv.append(aDiv)
                aDiv.setAttribute("id", "A_" + aKey)
                aDiv.classList.add("aDiv")
                let aRadio = document.createElement("input")

                // for checkbox question, create checkboxes, otherwise radio buttons
                if (qKey == "situations" || qKey == "leistungen"){
                    aRadio.setAttribute("type", "checkbox")  
                } else {
                    aRadio.setAttribute("type", "radio")
                }
                aRadio.setAttribute("name", "Q_" + qKey)
                aRadio.setAttribute("id", "Q_" + qKey + "_A_" + aKey)
                aRadio.setAttribute("value", aKey)
                aRadio.addEventListener("click", function(){  
                    selectAnswer(qKey, aKey)
                })
                let aLabel = document.createElement("label")
                aLabel.setAttribute("for", "Q_" + qKey + "_A_" + aKey)
                aLabel.innerHTML = aText

                aDiv.append(aRadio, aLabel)

                // Exceptions: Answers to not display
                    // hide formats that are not ready yet
                if (aKey =="SO"){
                    aDiv.style.display = "none"
                }
                    // hide least interaktive Option for Seminars
                if (qKey == "intSync" && aKey == "0" && answers["artLV"]=="SE"){
                    aDiv.style.display = "none"
                }

                // AT THE END OF THE LOOP: For checkbox questions, add "none of the above" as the last answer and highlight it
                if (qKey == "situations" || qKey == "leistungen"){ 
                    if (idx === array.length -1){
                        let aDiv = document.createElement("div"); qDiv.append(aDiv)
                        aDiv.setAttribute("id", "A_none")
                        aDiv.classList.add("aDiv","highlighted")
                        let aRadio = document.createElement("input")
                        aRadio.setAttribute("type", "checkbox")
                        
                        aRadio.setAttribute("name", "Q_" + qKey)
                        aRadio.setAttribute("id", "Q_" + qKey + "_A_none")
                        aRadio.setAttribute("value", "none")
                        aRadio.addEventListener("click", function(){  
                            selectAnswer(qKey, "none")
                        })
                        let aLabel = document.createElement("label")
                        aLabel.setAttribute("for", "Q_" + qKey + "_A_none")
                        aLabel.innerHTML = qKey == "situations" ? "Keine der genannten Situationen" : "keine der vorgenannten Leistungen"

                        aDiv.append(aRadio, aLabel)
                    } 
                } 
            })
            

        }

        if (true){
            let buttonContainer = document.createElement("div")
            buttonContainer.classList.add("buttonContainer")
            qDiv.append(buttonContainer)
            if (qKey == "TEXT_welcome"){
                buttonContainer.style.display = "none"
            }
            buttonContainer.append(pButton)
            buttonContainer.append(nButton)
            nButton.disabled = qKey=="situations" ||qKey=="leistungen" || qKey.includes("TEXT_") && qKey != "TEXT_labore" ? false : true
            pButton.style.display = nextQuestionIdx == 0 || qKey == "TEXT_welcome" ? "none" : "inline"
            nButton.style.display = nextQuestionIdx == 0 ? "none" : qKey == "TEXT_labore" ? "none" : "inline"

            // progress bar: check where we are!
            let progress = questionOrder.indexOf(activeQ)
            for (i=0; i< questionOrder.length; i++){
                if (i<=progress){
                    document.querySelector("#prog_" + i).classList.add("full")
                } else {
                    document.querySelector("#prog_" + i).classList.remove("full")
                }

            }
            // // text on upper left corner
            whichPart.parentElement.removeChild(whichPart)
            qDiv.append(whichPart)
            if (!qKey.includes("TEXT_")){
                whichPart.classList.add("show")
            } else {
                whichPart.classList.remove("show")
            }

            // add either to the bottom or to the top right
            if (qKey.includes("TEXT_")){
                if (qKey == "TEXT_labore" || qKey == "TEXT_welcome"){
                    progressBar.style.opacity=0
                } else {
                    progressBar.style.opacity=1
                }
                
                // progressBar.classList.remove("discreet")
                buttonContainer.append(progressBar)
            } else {
                progressBar.style.opacity=1
                // progressBar.classList.add("discreet")
                // qDiv.append(progressBar)
                buttonContainer.append(progressBar)
            }
            

        }

        setTimeout(function(){
            qDiv.classList.remove("upcoming", "past")
        }, 100)
        
        nextQuestionIdx += 1
    }

    function openInfoContainer(qKey){
        infoTimeout = setTimeout(()=>{
            document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.remove("closed")
            document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.add("opened")
            setTimeout(()=>{
                document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer > .infoText").classList.add("opened")
            }, 400)   
        }, 200)
    }

    function closeInfoContainer(qKey){
        clearTimeout(infoTimeout); clearTimeout(infoTimeout2)
        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer > .infoText").classList.remove("opened")
        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.remove("opened")
        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.add("closed")  
    }

    function selectAnswer(qKey, aKey){
        if (qKey == "situations" || qKey == "leistungen"){
            let aDiv = document.querySelector("#DIV_" + qKey + " > #A_" + aKey)
            if (aDiv.classList.contains("highlighted")){
                aDiv.classList.remove("highlighted")
            } else {
                aDiv.classList.add("highlighted")
            }

        } else {
            // formatting
            document.querySelectorAll("#DIV_" + qKey + " > .aDiv").forEach(function(aDiv){
                aDiv.classList.remove("highlighted")
            })
            document.querySelector("#DIV_" + qKey + " > #A_" + aKey).classList.add("highlighted")
            
        }
        
        // store the answer temporarily (before hitting "next")
        if (qKey!= "situations" && qKey != "leistungen"){
            answers[qKey] = aKey 
        } else {
            // special treatment for checkbox questions
            if (aKey != "none"){
                // normal behavior:
                let checked = document.querySelector("#Q_" + qKey + "_A_"+aKey).checked
                // case 1: the option was previously unselected and is being selected
                // case 2: the option was previously selected and is being deselected
                answers[aKey] = checked ? "ja" : "nein"
                // check if there are any options left selected, otherwise highlight 'none of the above'
                if (document.querySelectorAll("#DIV_" + qKey + " > .highlighted").length == 0){
                    document.querySelector("#DIV_" + qKey + " > #A_none").classList.add("highlighted")
                    if (qKey=="leistungen"){
                        answers["keineLeistungen"] = "ja"
                    }
                    
                } else {
                    // if other options are selected, deselect 'none of the above' option
                    document.querySelector("#DIV_" + qKey + " > #A_none").classList.remove("highlighted")
                    if (qKey=="leistungen"){
                        answers["keineLeistungen"] = "nein"
                    }
                }


            } else {
                // clicking on "none of the above" cancels everything else
                Object.keys(questionInfo[qKey]["antworten"]).forEach((a)=>{
                    document.querySelector("#DIV_" + qKey + " > #A_" + a).classList.remove("highlighted")
                    answers[a] = "nein"
                })
            }
            
        }
        
        // check if there would be a next question if this answer is selected; if so, enable the "Next Button"
        let includeNextQuestion = false
        let dummyIdx = nextQuestionIdx
        if (dummyIdx >= questionOrder.length){
            document.querySelector("#DIV_" + activeQ + " > .buttonContainer").append(sButton)
            sButton.style.display="inline"
            progressBar.style.opacity=0
            }
        while (dummyIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[dummyIdx]
            
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                if (sButton.style.display == "inline"){
                    document.body.appendChild(sButton)
                    sButton.style.display="none"
                }
                nButton.disabled = false
                break
            } else {
                dummyIdx += 1
            }
            // if we reach the end and don't find a valid question, display final submit button
            if (dummyIdx >= questionOrder.length){
                document.querySelector("#DIV_" + activeQ + " > .buttonContainer").append(sButton)
                sButton.style.display="inline"
                progressBar.style.opacity=0
            }
        }

        activeA = aKey
    }

    function proceedFromQuestion(cq=null){
        let cKey = cq? cq : activeQ
        // check if there is another question left to display and, if yes, do so.
        let includeNextQuestion = false
        while (nextQuestionIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[nextQuestionIdx]
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                hideQuestion(cKey)
                displayQuestion(nextQuestion, from="upcoming")
                break
            } else {
                nextQuestionIdx += 1
            }
        }
    }
    function submitSingleAnswer(qq=null, aa=null, proceed=true, resetRecent=true){
        let qKey = qq? qq : activeQ
        console.log(qq,  aa)
        let pKey = qKey
        let aKey = aa? aa : activeA
        
        if (resetRecent){
            console.log(recent, "reset")
            recent = []
        }
        
        if (proceed){
            let allRadios = document.getElementById("DIV_" + qKey).querySelectorAll("input")
            for (let radio of allRadios){
                if (radio.id == "Q_" + qKey + "_A_" + aKey){
                    radio.classList.add("selected")   
                }
                radio.setAttribute("disabled", true)
            }
        }

        let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
        let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]

        Object.entries(effects).forEach((entry)=>{
            if (Object.keys(activeScenarios).includes(entry[0])){ //  && entry[1] != "FUNC"){
                let scoreVal = +(activeScenarios[entry[0]])
                newScoreVal = scoreVal + entry[1]
                activeScenarios[entry[0]] = newScoreVal
                recent.push(entry[0])
                // console.log("APPLIED EFFECT,", entry[0], qKey)
            }
        })

        Object.entries(conditionalEffects).forEach((entry)=>{
            let sKey = entry[0]
            let sEffects = entry[1]
        
            Object.entries(sEffects).forEach((sEntry)=>{
                let conditions = sEntry[0]
                let score = sEntry[1]
                // separate conditions if more than one
                let met = andCheck(conditions)
                if (met){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal + score
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(sKey)
                    // console.log("APPLIED CONDITIONAL EFFECT,", entry[0], qKey)
                }
            })
            
        })

        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)

        if (proceed){
            proceedFromQuestion(pKey)
        }
    
    }
    function submitMultipleAnswers(answersToSubmit, parentQ){
        Object.entries(answersToSubmit).forEach((aEntry, idx, array)=>{
            submitSingleAnswer(aEntry[0], aEntry[1], proceed=false, resetRecent=idx==0)
            if (idx === array.length -1){
                submitSingleAnswer(parentQ, array[idx-1][0], proceed=true, resetRecent=false)
            } 
            
        })
        // // the following "submission" does nothing but advance to the next question
        // submitSingleAnswer("situations", "intKoll", proceed=true)
    }

    function undoAnswer(){
        // remove current question, unless it's just a text box
        let cQ = document.getElementById("DIV_" + activeQ)
        cQ.classList.add("upcoming")
        if (!activeQ.includes("TEXT_")){
            setTimeout(function(){
            cQ.remove()
        }, 500)
        } else {
            setTimeout(function(){
            cQ.querySelector(".buttonContainer").remove()
        }, 500)
        }

        
        // if user has already selected an answer for the current question and not submitted it:
        // remove the current answer from 'answers' before proceeding
        // note: this doesn't have any effect if the 'question' was just a textbox
        if (activeA){
            if (activeQ && activeQ != "situations"){
                delete answers[activeQ]
            }            
        }
        // for situationsQuestion: delete answer regardless
        if (activeQ == "situations"){
            Object.keys(situationsQuestion["antworten"]).forEach((key)=>{
                delete answers[key]
            })            
        }

        // get information about the last answered question and change variable activeQ
        if (activeQ == "situations"){
            activeQ = questionOrder[questionOrder.indexOf("situations")-1]
        } else {
            if (Object.keys(situationsQuestion["antworten"]).includes(Object.keys(answers)[Object.keys(answers).length-1])){
                activeQ = "situations"
            } else {
                // note: this works whether we are returning to a textbox or an actual question
                let oneBefore = questionOrder[questionOrder.indexOf(activeQ)-1]
                // oneBefore = Object.keys(answers)[Object.keys(answers).length-1] //this wouldn't work for text boxes, since they don't give answers

                // cases where a previous question/block must be skipped
                if ( oneBefore == "TEXT_labore"){
                    // 1. text about labs coming soon
                    activeQ = "artLV"
                } else if (oneBefore == "anzahlVL" && !answers["anzahlVL"]) {
                    // 2. question anzahlVL if Seminar had been chosen
                    activeQ = "artLV"
                } else if (oneBefore == "anzahlSE" && !answers["anzahlSE"]) {
                    // 3. question anzahlSE if Vorlesung had been chosen
                    activeQ = "anzahlVL"
                } else if (oneBefore == "nieSync" && !answers["nieSync"]){
                    // 4. question nieSync if it should have been skipped
                    activeQ = "limZPSt"
                } else if (oneBefore == "niePr" && !answers["niePr"]){
                    // 5. question niePr if it should have been skipped
                    if (!answers["nieSync"]){
                        // 6. maybe both nieSync and niePr were skipped
                        activeQ = "limZPSt"
                    } else {
                        activeQ = "nieSync"
                    }
                } else {
                    // default
                    activeQ = oneBefore
                }                

            }
        }
        
        nextQuestionIdx = questionOrder.indexOf(activeQ)

        activeA = null
        let lastAnswer = {}
        if (activeQ == "situations"  || activeQ == "leistungen"){
            Object.keys(questionInfo[activeQ]["antworten"]).forEach((key)=>{
                lastAnswer[key] = answers[key]
            })    
        } else {
            lastAnswer[activeQ] = answers[activeQ]  
        }

        
        // delete the stored answers of the last answered question
        delete answers[activeQ]
        if (activeQ == "situations" || activeQ == "leistungen"){
            Object.keys(questionInfo[activeQ]["antworten"]).forEach((key)=>{
                delete answers[key]
            })            
        }

        function undoAllEffects(qKey, aKey){
            console.log(qKey, aKey)
            recent = []
            // calculate score provided by last answer for each code (but this time subtract it!)
            let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
            let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]

            Object.entries(effects).forEach((entry)=>{
                if (Object.keys(activeScenarios).includes(entry[0])){ // && entry[1] != "FUNC"){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal - entry[1]
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(entry[0])
                    // console.log("REVERSED EFFECT,", entry[0], qKey)
                }
            })

            Object.entries(conditionalEffects).forEach((entry)=>{
                let sKey = entry[0]
                let sEffects = entry[1]
                Object.entries(sEffects).forEach((sEntry)=>{
                    let conditions = sEntry[0]
                    let score = sEntry[1]
                    
                    // separate conditions if more than one
                    let met = andCheck(conditions)
                    if (met){
                        let scoreVal = +(activeScenarios[entry[0]])
                        newScoreVal = scoreVal - score
                        activeScenarios[entry[0]] = newScoreVal
                        recent.push(sKey)
                        // console.log("REVERSED CONDITIONAL EFFECT,", entry[0], qKey)
                    }
                })
            })
        }

        if (!activeQ.includes("TEXT_")){
            console.log(lastAnswer)
            Object.entries(lastAnswer).forEach((response)=>{
            qKey = response[0]
            aKey = response[1]
            undoAllEffects(qKey, aKey)
        })
        }

        // let qKey = activeQ
        // let aKey = lastAnswer

        // remove previous question and display it again
        if (activeQ.includes("TEXT_")){
            document.getElementById("DIV_" + activeQ).style.display="none"
        }
        else {
            document.getElementById("DIV_" + activeQ).remove()
        }
        displayQuestion(activeQ, from="past")

        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)

    }

    // shows live-scores below tool for testing purposes
    function listActiveScenarios(sObju){
        sObj = Object.entries(sObju).sort(([,a],[,b]) => b-a).reduce((r, [k, v]) => ({ ...r, [k]: v }), {});
        sCont.innerHTML = ""
        Object.entries(sObj).forEach((entry)=>{
            sKey = entry[0]
            sVal = entry[1]
            let tr = document.createElement("p")
            let name = document.createElement("span")
            name.classList.add("sName")
            let score = document.createElement("span")
            name.innerHTML = sKey
            let scenarioTitle = all_texts[sKey.slice(0,-6)].name
            name.setAttribute("title", scenarioTitle)
            score.innerHTML = sVal
            score.setAttribute("id", "SCORE_" + sKey)
            score.classList.add("score")
            tr.append(name, score)
            if (recent.includes(sKey)){
                tr.classList.add("recent")
            }
            sCont.append(tr)
        })

        for (let score of document.querySelectorAll(".score")){
            let value = +(score.innerHTML)
            if (value > 0){
                score.style.color = "#0e7700"
            } else if (value <0){
                score.style.color = "#d93300"
            } else {
                score.style.color = "#585858"
            }
        }
    }

    function getResult(finalResults){
        // decide which scenarios to show!
        topResults = getTopScenarios(finalResults)
        let firstResult = topResults[0]
        window.open("var_result.html?shownScenario=" + firstResult + "&topTier=" + JSON.stringify(topResults), "_self")
    }

    // Auxiliary funcitons (specialized)
    function getTopScenarios(results){
        shownScenarios = []
        // determine top 3 scores (multiple scenarios can have the same score)
        let firstScore = Math.max(...Object.values(results))
        let topTier = Object.entries(results).filter(([k,v])=>v==firstScore).reduce((r, [k,v])=>[...r,k], []) // returns list of scenarios

        let secondScore = Math.max(...Object.values(Object.entries(results).filter(([k,v])=>v<firstScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let secondTier = Object.entries(results).filter(([k,v])=>v==secondScore).reduce((r, [k,v])=>[...r,k], [])

        let thirdScore = Math.max(...Object.values(Object.entries(results).filter(([k,v])=>v<secondScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let thirdTier = Object.entries(results).filter(([k,v])=>v==thirdScore).reduce((r, [k,v])=>[...r,k], [])
        
        for (let i=0; i<(topTier.length + secondTier.length + thirdTier.length); i++){
            // first tier: include all non-duplicates
            if (i<topTier.length){
                let scenarioToAdd = topTier[i]
                // do not add scenarios with same format hyb, rem, ringonl, etc.
                if (notDuplicate(scenarioToAdd, shownScenarios)){
                    shownScenarios.push(scenarioToAdd)
                }

            } else {
                // second tier: don't consider if score less than zero
                if (i < (topTier.length+secondTier.length) && secondScore>=0){
                    let j = i - topTier.length
                    let scenarioToAdd = secondTier[j]
                    if (notDuplicate(scenarioToAdd, shownScenarios)){
                        shownScenarios.push(scenarioToAdd)
                    }

                } else {
                    // third tier: don't consider if score less than zero
                    if (thirdScore>=0){
                        let k = i - topTier.length - secondTier.length
                        let scenarioToAdd = thirdTier[k]
                        if (notDuplicate(scenarioToAdd, shownScenarios)){
                            shownScenarios.push(scenarioToAdd)
                        }
                    }

                    }
                }
            if (shownScenarios.length >=maxShownAnswers){
                break
            }     
            
        }
        return shownScenarios
    }

    // logic
    function includeCheck(qKey){
        // checks if a question should be displayed
        // assumes that questions have been ordered correctly, otherwise results may be unexpected
        if (qKey.includes("TEXT_")){
            
            let condition = (qKey == "TEXT_labore") ? "artLV=PR" : true
            if (condition == true){
                return true
            } else {
                return andCheck(condition)
            }
        } else {
            let condition = questionInfo[qKey]["condition"]
            if (condition == true){
                return true
            } else {
                return andCheck(condition)
            }
        }        
    }

    function andCheck(conditions){
        // checks if all conditions qKey=aKey are simultaneously true
        let i = 0
        while (i < 10){
            
            [qKey, aKey] = conditions.split("+")[i].split("=")
            if (qKey.includes("!")){
                // check if it's a NOT test
                qKeyR = qKey.split("!")[0]
                if (answers[qKeyR] == aKey || !answers[qKeyR]){
                    return false
                } else {
                    i += 1
                }
            } else {
                if (answers[qKey] != aKey){
                return false
                } else {
                    i += 1
                }
            }

            if (i >= conditions.split("+").length){
                return true
            }
        }
        conditions.split("+").forEach((condition, i)=>{
            [qKey, aKey] = condition.split("=")
            if (answers[qKey] != aKey){
                if (i <4){
                    realConditions[i] = false
                } else {
                    console.log("only up to 4 simultaneous conditions supported; the rest are ignored")
                }
            }
        })
        
    }
    
    function notDuplicate(newScenario, shownScenarios){
        sType = newScenario.split("-")[1]
        if (shownScenarios.map((str)=>str.split("-")[1]).includes(sType)){
            // if the type of scenario is the same, still include if there is asynchronous participation alternative for one scenario
            let matchingScenarios = shownScenarios.filter((str)=>str.split("-")[1] == sType)
            if (matchingScenarios.length > 1){
                // can't add same scenario a third time!
                return false
            }
            let matchingScenario = matchingScenarios[0]
            let asyncNew = newScenario.split("-")[3] // asynchronous participation mode of new scenario
            let asyncMatching = matchingScenario.split("-")[3] // asynchronous participation mode of matching scenario
            if ([asyncNew, asyncMatching].includes("3") && asyncNew != asyncMatching){
                return true
            } else {
                return false
            }
        } else {
            return true
        }
    }


     
</script>
</body>
</html>
