<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Entscheidungshilfe</title>
  <meta charset="utf-8" />
  <meta http-equiv="content-language" content="de">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
  <link rel="stylesheet" href="../assets/css/eb.css" />
<script src="../assets/js/jquery.min.js"></script>
</head>
<body class="is-preload" lang="de">
<h2>Fragereihe-Ansicht - Entscheidungshilfe Online und Hybride Lehre</h2>
<div style="display: table; width: 100%">
    <div id="questions" class="qCont"></div>
    <div id="result" class="rCont" style="display:none">Result</div>
    <div id="scenarios" class="sCont"></div>
    
</div>
<script>
    const qCont = document.getElementById("questions")
    const sCont = document.getElementById("scenarios")
    var all_data, questionInfo, all_scenarios
    
    var activeQ, activeA
    var nextQuestionIdx = 0

    var scenarios = {}
    const colorMapping = {
        "-100": "#C00000",
        "-2": "#f77e59",
        "-1": "#ffa185",
        "0": "#FFEB84",
        "1": "#D4DE89",
        "2": "#A9D08E",
        "FUNC": "#FFFFAA"
    }

    const questionOrder = [ 
        'artLV', 
        'modulCombo',
        'LZiP',
        'LZsy', 
        'niePr',
        'nieSync',
        // 'wohnLP',
        'regAbw',
        "onlBereit", 
        "limZPSt",
        "onlZugang",
        "IntAsync",
        'gaeste', 
        'gaesteMittel',
        "exkur",
        "exkurMittel",
        'begrAnz',
        "intKoll"
    ]
    var answers = {}
    var activeScenarios = {}
    var recent = []

    const maxShownAnswers = 4

    // Previous Question, Next Question, Submit buttons (will be moved around)
    var pButton = document.createElement("button"); document.body.append(pButton)
    pButton.classList.add("prevButton")
    pButton.setAttribute("id", "prevButton")
    pButton.innerHTML = "Vorherige Frage"
    pButton.addEventListener("click", function(){
        undoAnswer()
    })
    pButton.style.display = "none"

    let nButton = document.createElement("button"); document.body.append(nButton)
    nButton.classList.add("nextButton")
    nButton.setAttribute("id", "nextButton")
    nButton.innerHTML = "NÃ¤chste Frage"
    nButton.addEventListener("click", function(){
        submitAnswer()
    })
    nButton.style.display = "none"

    let sButton = document.createElement("button"); document.body.append(sButton)
    sButton.classList.add("nextButton")
    sButton.setAttribute("id", "submitButton")
    sButton.innerHTML = "Absenden"
    sButton.addEventListener("click", function(){
        getResult()
    })
    sButton.style.display = "none"

    $.getJSON("data.json", function(json){
        all_data = json
        questionInfo = json['questions']
        all_scenarios = json['scenarios']
        Object.entries(all_scenarios).forEach((s)=>{activeScenarios[s[0]] = 0})
        displayQuestion(questionOrder[nextQuestionIdx])
    })
    
    function displayQuestion(qKey){
        let q = questionInfo[qKey]
        let qText = q.text

        activeQ = qKey
        activeA = null

        let qDiv = document.createElement("div"); qCont.append(qDiv)
        qDiv.setAttribute("id", "DIV_" + qKey)
        let qP = document.createElement("p"); qDiv.append(qP)
        qP.setAttribute("id", "Q_" + qKey)
        qP.innerHTML = qText

        Object.entries(q.antworten).forEach((a)=>{
            let aKey = a[0]
            let aText = a[1].text
            let aEffects = a[1].effects
            let aConditionalEffects= a[1].conditionalEffects

            let aDiv = document.createElement("div"); qDiv.append(aDiv)
            let aRadio = document.createElement("input")
            aRadio.setAttribute("type", "radio")
            aRadio.setAttribute("name", "Q_" + qKey)
            aRadio.setAttribute("id", "Q_" + qKey + "_A_" + aKey)
            aRadio.setAttribute("value", aKey)
            aRadio.addEventListener("click", function(){
                
                selectAnswer(qKey, aKey)
            })
            let aLabel = document.createElement("label")
            aLabel.setAttribute("for", "Q_" + qKey + "_A_" + aKey)
            aLabel.innerHTML = aText

            aDiv.append(aRadio, aLabel)
            if (aKey == "PR" | aKey =="SO"){
                aDiv.style.display = "none"
            }            

        })

        qDiv.append(pButton)
        qDiv.append(nButton)
        nButton.disabled = true
        pButton.style.display = nextQuestionIdx == 0 ? "none" : "inline"
        nButton.style.display = "inline"
        
        nextQuestionIdx += 1
    }

    function selectAnswer(qKey, aKey){
        // check if there would be a next question if this answer is selected; if so, enable the "Next Button"
        let includeNextQuestion = false
        let dummyIdx = nextQuestionIdx
        if (dummyIdx >= questionOrder.length){
                document.getElementById("DIV_" + activeQ).append(sButton)
                sButton.style.display="inline"
            }
        while (dummyIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[dummyIdx]
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                nButton.disabled = false
                break
            } else {
                dummyIdx += 1
            }
            console.log(dummyIdx)

        }

        answers[qKey] = aKey
        activeA = aKey
    }

    function submitAnswer(){
        qKey = activeQ
        aKey = activeA
        let allRadios = document.getElementById("DIV_" + qKey).querySelectorAll("input")
        recent = []
        for (let radio of allRadios){
            if (radio.id == "Q_" + qKey + "_A_" + aKey){
                radio.classList.add("selected")   
            }
            radio.setAttribute("disabled", true)
        }

        let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
        let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]

        Object.entries(effects).forEach((entry)=>{
            if (Object.keys(activeScenarios).includes(entry[0]) && entry[1] != "FUNC"){
                let scoreVal = +(activeScenarios[entry[0]])
                newScoreVal = scoreVal + entry[1]
                activeScenarios[entry[0]] = newScoreVal
                recent.push(entry[0])
            }
        })

        Object.entries(conditionalEffects).forEach((entry)=>{
            let sKey = entry[0]
            let sEffects = entry[1]
        
            Object.entries(sEffects).forEach((sEntry)=>{
                let conditions = sEntry[0]
                let score = sEntry[1]
                // separate conditions if more than one
                let met = andCheck(conditions)
                if (met){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal + score
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(sKey)
                }
            })
            
        })

        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)

        // check if there is another question left to display and, if yes, do so.
        let includeNextQuestion = false
        while (nextQuestionIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[nextQuestionIdx]
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                displayQuestion(nextQuestion)
                break
            } else {
                nextQuestionIdx += 1
            }
        }
    }
    
    function undoAnswer(){
        // remove current question
        document.getElementById("DIV_" + activeQ).remove()
        
        // if user has already selected an answer for the current question and not submitted it:
        // remove the current answer from 'answers' before proceeding
        if (activeA){
            delete answers[activeQ]
        }

        // get information about the last answered question
        activeQ = Object.keys(answers)[Object.keys(answers).length-1]
        nextQuestionIdx = questionOrder.indexOf(activeQ)
        activeA = null
        let lastAnswer = answers[activeQ]
        delete answers[activeQ]

        let qKey = activeQ
        let aKey = lastAnswer

        let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
        let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]
        
        recent = []
        // calculate score provided by last answer for each code (but this time subtract it!)
        Object.entries(effects).forEach((entry)=>{
            if (Object.keys(activeScenarios).includes(entry[0]) && entry[1] != "FUNC"){
                let scoreVal = +(activeScenarios[entry[0]])
                newScoreVal = scoreVal - entry[1]
                activeScenarios[entry[0]] = newScoreVal
                recent.push(entry[0])
            }
        })

        Object.entries(conditionalEffects).forEach((entry)=>{
            let sKey = entry[0]
            let sEffects = entry[1]
            Object.entries(sEffects).forEach((sEntry)=>{
                let conditions = sEntry[0]
                let score = sEntry[1]
                // console.log(conditions, score)
                // separate conditions if more than one
                let met = andCheck(conditions)
                if (met){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal - score
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(sKey)
                }
            })
            
        })

        // remove previous question and display it again
        document.getElementById("DIV_" + activeQ).remove()
        displayQuestion(activeQ)

        setTimeout(()=>{
            listActiveScenarios(activeScenarios)
        }, 100)
    }

    function listActiveScenarios(sObju){
        sObj = Object.entries(sObju).sort(([,a],[,b]) => b-a).reduce((r, [k, v]) => ({ ...r, [k]: v }), {});
        sCont.innerHTML = ""
        Object.entries(sObj).forEach((entry)=>{
            sKey = entry[0]
            sVal = entry[1]
            let tr = document.createElement("tr")
            let name = document.createElement("th")
            let score = document.createElement("td")
            name.innerHTML = sKey 
            score.innerHTML = sVal
            score.setAttribute("id", "SCORE_" + sKey)
            score.classList.add("score")
            tr.append(name, score)
            if (recent.includes(sKey)){
                tr.classList.add("recent")
            }
            sCont.append(tr)
        })

        for (let score of document.querySelectorAll(".score")){
            let value = +(score.innerHTML)
            if (value > 0){
                score.style.color = "#0e7700"
            } else if (value <0){
                score.style.color = "#d93300"
            } else {
                score.style.color = "#585858"
            }
        }
    }

    function getResult(topResults){
        // filteredScenarios = Object.entries(activeScenarios).filter(([key, val])=> val > -85).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})
        // sortedScenarios = Object.entries(filteredScenarios).sort(([,a],[,b]) => b-a).reduce((r, [k, v]) => ({ ...r, [k]: v }), {});

        // determine top 3 scores (multiple scenarios can have the same score)
        let firstScore = Math.max(...Object.values(topResults))
        let topTier = Object.entries(topResults).filter(([k,v])=>v==firstScore).reduce((r, [k,v])=>[...r,k], []) // returns list of scenarios

        let secondScore = Math.max(...Object.values(Object.entries(topResults).filter(([k,v])=>v<firstScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let secondTier = Object.entries(topResults).filter(([k,v])=>v==secondScore).reduce((r, [k,v])=>[...r,k], [])

        let thirdScore = Math.max(...Object.values(Object.entries(topResults).filter(([k,v])=>v<secondScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let thirdTier = Object.entries(topResults).filter(([k,v])=>v==thirdScore).reduce((r, [k,v])=>[...r,k], [])
        
        // decide which scenarios to show!
        let shownScenarios = []
        
        for (let i=0; i<maxShownAnswers; i++){
            // first tier: include all non-duplicates
            if (i<topTier.length){
                let scenarioToAdd = topTier[i]
                let sType = scenarioToAdd.split("-")[1]
                // do not add scenarios with same format hyb, rem, ringonl, etc.
                if (!shownScenarios.map((str)=>str.split("-")[1]).includes(sType)){
                    shownScenarios.push(scenarioToAdd)
                }

            } else {
                // second tier: don't consider if score less than zero
                if (i < (topTier.length+secondTier.length)){
                    let j = i - topTier.length
                    let scenarioToAdd = secondTier[j]
                    let sType = scenarioToAdd.split("-")[1]
                    if (!shownScenarios.map((str)=>str.split("-")[1]).includes(sType) && secondScore>=0){
                        shownScenarios.push(scenarioToAdd)
                    }

                } else {
                    // third tier: don't consider if score less than zero
                    let k = i - topTier.legnth - secondTier.length
                    let scenarioToAdd = thirdTier[k]
                    let sType = scenarioToAdd.split("-")[1]
                    if (!shownScenarios.map((str)=>str.split("-")[1]).includes(sType)){
                        shownScenarios.push(scenarioToAdd)
                    }
                    }
                }          
            
        }

        console.log(topTier, secondTier, thirdTier)
        return shownScenarios

    }

    // Auxiliary functions
    function includeCheck(qKey){
        // checks if a question should be displayed
        // assumes that questions have been ordered correctly, otherwise results may be unexpected
        let condition = questionInfo[qKey]["condition"]
        if (condition == true){
            return true
        } else {
            return andCheck(condition)
        }
        
    }

    function andCheck(conditions){
        // checks if all conditions qKey=aKey are simultaneously true
        let i = 0
        while (i < 10){
            [qKey, aKey] = conditions.split("+")[i].split("=")
            if (qKey.includes("!")){
                // check if it's a NOT test
                qKeyR = qKey.split("!")[0]
                if (answers[qKeyR] == aKey | !answers[qKeyR]){
                    return false
                } else {
                    i += 1
                }
            } else {
                if (answers[qKey] != aKey){
                return false
                } else {
                    i += 1
                }
            }

            if (i >= conditions.split("+").length){
                return true
            }
        }
        conditions.split("+").forEach((condition, i)=>{
            [qKey, aKey] = condition.split("=")
            if (answers[qKey] != aKey){
                if (i <4){
                    realConditions[i] = false
                } else {
                    console.log("only up to 4 simultaneous conditions supported; the rest are ignored")
                }
            }
        })
        
    }

    topResults =  {'se-rem-2-3-2': 2,
    'se-rem-2-1-1': 2, 
    'se-praes-2-3-2': 2, 
    'se-praeshybwechs-2-3-2': 2, 
    'se-hyb-2-3-2': 1, 
    'se-onl-2-3-2': 1,
    'se-onl-2-1-1': 0,}        
</script>
</body>
</html>