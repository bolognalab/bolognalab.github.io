<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Entscheidungshilfe</title>
  <meta charset="utf-8" />
  <meta http-equiv="content-language" content="de">
  <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
  <noscript><link rel="stylesheet" href="../assets/css/noscript.css" /></noscript>
  <link rel="stylesheet" href="../assets/css/eb.css" />
<script src="../assets/js/jquery.min.js"></script>
<style>
    .qCont {
        background-color: var(--backgroundLightBlue);
        /* padding: 20px 20px; */
        overflow: hidden;
        position: relative;
        height: 30em;
        /* background-image: url("../images/entscheidungshilfe/treeTemp.svg");
        background-size: 80%; 
        background-repeat: no-repeat;
        background-position: 0% 85%;
        background-blend-mode: normal; */
        
    }
    .backgroundImage {
        position: absolute;
        top: 40%;
        left: 30%;
        width: 70%;
        transform: translate(0, -50%) rotate(180deg);
        filter: var(--networkBlueFilter);
        opacity: 0.2;
    }
    #welcome {
        background: rgba(255,255,255, 0.8)
    }
    #welcome h1 {
        color: var(--networkBlack);
        text-align: center;
        font-size: 24px;
        width: 60%;
        margin: auto;
        
    }
    #welcome p {
        /* background: rgba(18, 161, 154, 0.8);; */
        border-radius: 0.8em;
        width: 60%;
        margin: 2em auto;
        padding: 0.8em 1em 1.5em 1em;
        color: var(--networkBlack);
        text-align: center;
    }
    #start {
        background: var(--networkTurqoise)
    }
    #start, .qCont .submitButton {
        border: 3px solid rgba(255,255,255,0.7);
    }
    #start:hover {
        background: hwb(177 7% 27%);
    }
    .qCont .submitButton:hover {
        background: hwb(205 6% 12%);
    }
    .qDiv {
        /* background: rgba(18, 161, 154, 0.8); */
        background: white;
        padding: 20px 20px;
        /* color: white; */
        color: var(--networkBlack);
        margin-bottom: 20px;
        position: absolute;
        left: 50%;
        top: 50%;
        width: calc(100% - 5em);
        max-width: 630px;
        transform: translate(-50%, -50%);
        opacity: 1;
        transition: all 0.5s ease;
        box-shadow: rgba(99, 99, 99, 0.2) 0px 2px 8px 0px;
    }
    .qDiv.upcoming {
        left: 150%;
        opacity: 0;
    }
    .qDiv.past {
        left: -50%;
        opacity: 0;
    }
    
    .aDiv {
        margin-bottom: 0.4em;
        padding: 0 1em;
        width: calc(100%-40px);
        transition: all 0.5s ease;
        border-radius: 0.4em;
        border: 2px rgba(18, 161, 154, 0.2) solid;
    }
    .aDiv:hover {
        background: rgba(18, 161, 154, 0.2) 
    }
    .aDiv.highlighted {
        background: rgb(18, 161, 154);
        border: 2px rgb(18, 161, 154) solid;
        color: white;
    }
    input[type='radio']{
       opacity: 0;
       width: 1px;
       height: 1px;
       margin-left: -1px;
       margin-right: 0;
       overflow: hidden;
    }
    input[type='radio'] + label {
        background: rgba(255,255,255,0);
        cursor: pointer;
        width: calc(100%);
        display: inline-block;
        padding: 0.5em 1em;
        margin-left: -1em;
        margin-right: -1em;
        border-radius: 0.4em;
    }
    input[type='radio']:disabled + label {
        cursor: auto;
    }
    .buttonContainer {
        width: 100%;
        height: 3em;
        position: relative;
        margin-top: 1em;
    }

    .qCont .submitButton, .nextButton.asIcon, .prevButton.asIcon {
        position: absolute;
        top: 50%;
        transform: translate(-50%, -50%);
        height: 3em;
        margin: 0 0;
        transition: all 0.4s ease;
        cursor: pointer;
    }
    .nextButton.asIcon, .prevButton.asIcon {
        width: 3em;
        border-radius: 3em;
        background: rgba(0,0,0,0);
        background-repeat: no-repeat;
        background-size: 0.8em;
        border: 2px solid var(--networkTurqoise);
        filter: var(--networkTurqoiseFilter);
        opacity: 0.7;
        /* filter: brightness(0) saturate(100%) invert(99%) sepia(80%) saturate(0%) hue-rotate(11deg) brightness(109%) contrast(100%); */
    }
    .nextButton.asIcon {
        background-image: url("../images/fwd3.svg");
        background-position: 55% 50%;
        left: calc(85% + 0em)
    }
    .prevButton.asIcon {
        background-image: url("../images/bwd3.svg");
        background-position: 45% 50%;
        left: calc(15% - 0em)
    }
    .nextButton.asIcon:disabled, .prevButton.asIcon:disabled {
        opacity: 0.2;
        transition: all 0.4s ease;
        cursor: auto;
    }
    .qCont .submitButton {
        left: 50%;
        border-radius: 1em;
        padding: 0.5em 1em;
        color: white;
        font-size: 16px;
        font-weight: bold;
        letter-spacing: 0.05em;
        background: var(--networkBlue)
    }
    .infoContainer {
        position: absolute;
        left: 50%;
        transform: translate(-50%, -50%);
        font-size: 12px;
        transition: all 0.4s ease;
        display: table;
        margin: 0 0;
    }
    .infoContainer.closed {
        top: 50%;
        width: 25px;
        overflow:hidden;
    }
    .infoContainer.opened {
        top: 0%;
        transform: translate(-50%, 0);
        width: 32%;
    }
    .infoIcon {
        display: table-cell;
        vertical-align: middle;
        width: 20px;
        margin-right: 0.5em;
        filter: var(--networkTurqoise);
        transition: all 0.2s ease;

    }
    .infoContainer.closed > .infoIcon {
        cursor: pointer
    }
    .infoContainer.closed > .infoIcon:hover {
        width: 25px;
    }
    .infoText {
        transition: all 0.4 ease;
    }
    .infoText {
        display: none;
        color: rgba(255,255,255,0);
        opacity: 0;
        background: rgba(55, 55, 54,0.6);
        padding: 0.5em;
        border-radius: 0.5em;
    }
    .infoText.opened {
        display: table-cell;
        vertical-align: middle;
        color: rgba(255,255,255,1);
        opacity: 1;
    }
</style>
</head>
<body class="is-preload" lang="de">
<div style="width: 100%">
    
    <div id="questions" class="qCont">
        <img class="backgroundImage" src = "../images/entscheidungshilfe/treeTemp.svg" />
        <div id="welcome" class="qDiv">
            <h2 style="text-align: center"><img src="../images/entscheidungshilfe/NHL_logo.svg" style="width: 40%" /></h2>
            <h1>Entscheidungsbaum Online und Hybride Lehre</h3>
            <p>Überlegen Sie, in einem neuen Format zu unterrichten? Beantworten Sie die folgenden Fragen und entdecken Sie, welches Szenario für Sie am besten passt!</p>
            <div class="buttonContainer"><button id="start" class="submitButton" onclick="start()" style="display:none">Beginnen</button></div>
        </div>
    </div>    
</div>
<script src="../assets/js/jquery.csv.js"></script>
<script>
    const qCont = document.getElementById("questions")

    var all_data, questionInfo, all_scenarios, infoTimeout, infoTimeout2

    var activeQ, activeA
    var nextQuestionIdx = 0

    var scenarios = {}

    const questionOrder = [ 
        'artLV', 
        // 'modulCombo',
        'LZiP',
        // 'niePr',
        // 'nieSync',
        // 'regAbw',
        // "onlBereit", 
        // "limZPSt",
        // "onlZugang",
        // 'LZsy', 
        // "IntAsync",
        // 'gaeste', 
        // 'gaesteMittel',
        // "exkur",
        // "exkurMittel",
        // 'begrAnz',
        // "intKoll"
    ]

    var answers = {}
    var activeScenarios = {}
    var recent = []
    var topResults

    const maxShownAnswers = 4
   

    // Previous Question, Next Question, Submit buttons (will be moved around)
    var pButton = document.createElement("button"); document.body.append(pButton)
    pButton.classList.add("prevButton", "asIcon")
    pButton.setAttribute("id", "prevButton")
    // pButton.innerHTML = "Vorherige Frage"
    pButton.addEventListener("click", function(){
        undoAnswer()
    })
    pButton.style.display = "none"

    let nButton = document.createElement("button"); document.body.append(nButton)
    nButton.classList.add("nextButton", "asIcon")
    nButton.setAttribute("id", "nextButton")
    // nButton.innerHTML = "Nächste Frage"
    nButton.addEventListener("click", function(){
        submitAnswer()
    })
    nButton.style.display = "none"

    let sButton = document.createElement("button"); document.body.append(sButton)
    sButton.classList.add("submitButton")
    sButton.setAttribute("id", "submitButton")
    sButton.innerHTML = "Absenden"
    sButton.addEventListener("click", function(){
        getResult(activeScenarios)
    })
    sButton.style.display = "none"

    $.getJSON("data.json", function(json){
        all_data = json
        questionInfo = json['questions']
        all_scenarios = json['scenarios']
        Object.entries(all_scenarios).forEach((s)=>{activeScenarios[s[0]] = 0})
        document.querySelector("#start").style.display = "block"
        // displayQuestion(questionOrder[nextQuestionIdx], from="start")
    })
    function start(){
        document.querySelector("#welcome").style.display="none"
        displayQuestion(questionOrder[nextQuestionIdx], from='start')
    }
    function hideQuestion(qKey){
        // hiding question container when next question arrives
        let qToHide = document.getElementById("DIV_" + qKey)
        // if (qToHide.classList.contains(""))
        qToHide.classList.remove("upcoming")
        qToHide.classList.add("past")
        // qToHide.style.display = "none"
    }
    function displayQuestion(qKey, from="upcoming"){
        let q = questionInfo[qKey]
        let qText = q.text

        activeQ = qKey
        activeA = null

        let qDiv = document.createElement("div"); qCont.append(qDiv)
        qDiv.setAttribute("id", "DIV_" + qKey)
        if (from != "start"){
            qDiv.classList.add("qDiv", from)
        } else {
            qDiv.classList.add("qDiv")
        }
        
        let qP = document.createElement("p"); qDiv.append(qP)
        qP.setAttribute("id", "Q_" + qKey)
        qP.innerHTML = qText

        Object.entries(q.antworten).forEach((a)=>{
            let aKey = a[0]
            let aText = a[1].text
            let aEffects = a[1].effects
            let aConditionalEffects= a[1].conditionalEffects

            let aDiv = document.createElement("div"); qDiv.append(aDiv)
            aDiv.setAttribute("id", "A_" + aKey)
            aDiv.classList.add("aDiv")
            let aRadio = document.createElement("input")
            aRadio.setAttribute("type", "radio")
            aRadio.setAttribute("name", "Q_" + qKey)
            aRadio.setAttribute("id", "Q_" + qKey + "_A_" + aKey)
            aRadio.setAttribute("value", aKey)
            aRadio.addEventListener("click", function(){  
                selectAnswer(qKey, aKey)
            })
            let aLabel = document.createElement("label")
            aLabel.setAttribute("for", "Q_" + qKey + "_A_" + aKey)
            aLabel.innerHTML = aText

            aDiv.append(aRadio, aLabel)
            if (aKey == "PR" | aKey =="SO"){
                aDiv.style.display = "none"
            }            

        })
        let buttonContainer = document.createElement("div")
        buttonContainer.classList.add("buttonContainer")
        qDiv.append(buttonContainer)

        buttonContainer.append(pButton)
        buttonContainer.append(nButton)
        nButton.disabled = true
        pButton.style.display = nextQuestionIdx == 0 ? "none" : "inline"
        nButton.style.display = "inline"

        // add 'additional info' if present
        if (q.addInfo){
            let infoContainer = document.createElement("p"); buttonContainer.append(infoContainer)
            infoContainer.classList.add("infoContainer", "closed")
            let infoIcon = document.createElement("img");infoContainer.append(infoIcon)
            infoIcon.setAttribute("src", "../images/entscheidungshilfe/infoIcon.svg")
            infoIcon.classList.add("infoIcon")
            let infoText = document.createElement("span"); infoContainer.append(infoText)
            infoText.classList.add("infoText")
            infoText.innerHTML = q.addInfo

            infoContainer.addEventListener("mouseenter", ()=>{
                infoTimeout = setTimeout(()=>{
                    document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.remove("closed")
                    document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.add("opened")
                    setTimeout(()=>{
                        document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer > .infoText").classList.add("opened")
                    }, 400)   
                }, 200)
            })
            infoContainer.addEventListener("mouseleave", ()=>{
                clearTimeout(infoTimeout); clearTimeout(infoTimeout2)
                document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer > .infoText").classList.remove("opened")
                document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.remove("opened")
                document.querySelector("#DIV_" + qKey + " .buttonContainer > .infoContainer").classList.add("closed")   
            })
        }


        setTimeout(function(){
            qDiv.classList.remove("upcoming", "past")
        }, 100)
        
        nextQuestionIdx += 1
    }

    function selectAnswer(qKey, aKey){
        // formatting
        document.querySelectorAll("#DIV_" + qKey + " > .aDiv").forEach(function(aDiv){
            aDiv.classList.remove("highlighted")
        })
        document.querySelector("#DIV_" + qKey + " > #A_" + aKey).classList.add("highlighted")
        // check if there would be a next question if this answer is selected; if so, enable the "Next Button"
        let includeNextQuestion = false
        let dummyIdx = nextQuestionIdx
        if (dummyIdx >= questionOrder.length){
            document.querySelector("#DIV_" + activeQ + " > .buttonContainer").append(sButton)
            sButton.style.display="inline"
            }
        while (dummyIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[dummyIdx]
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                nButton.disabled = false
                break
            } else {
                dummyIdx += 1
            }

        }

        answers[qKey] = aKey
        activeA = aKey
    }

    function submitAnswer(){
        qKey = activeQ
        pKey = qKey
        aKey = activeA
        let allRadios = document.getElementById("DIV_" + qKey).querySelectorAll("input")
        recent = []
        for (let radio of allRadios){
            if (radio.id == "Q_" + qKey + "_A_" + aKey){
                radio.classList.add("selected")   
            }
            radio.setAttribute("disabled", true)
        }

        let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
        let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]

        Object.entries(effects).forEach((entry)=>{
            if (Object.keys(activeScenarios).includes(entry[0]) && entry[1] != "FUNC"){
                let scoreVal = +(activeScenarios[entry[0]])
                newScoreVal = scoreVal + entry[1]
                activeScenarios[entry[0]] = newScoreVal
                recent.push(entry[0])
            }
        })

        Object.entries(conditionalEffects).forEach((entry)=>{
            let sKey = entry[0]
            let sEffects = entry[1]
        
            Object.entries(sEffects).forEach((sEntry)=>{
                let conditions = sEntry[0]
                let score = sEntry[1]
                // separate conditions if more than one
                let met = andCheck(conditions)
                if (met){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal + score
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(sKey)
                }
            })
            
        })

        // check if there is another question left to display and, if yes, do so.
        let includeNextQuestion = false
        while (nextQuestionIdx < questionOrder.length && includeNextQuestion == false){
            let nextQuestion = questionOrder[nextQuestionIdx]
            includeNextQuestion = includeCheck(nextQuestion)
            if (includeNextQuestion){
                hideQuestion(pKey)
                displayQuestion(nextQuestion, from="upcoming")
                break
            } else {
                nextQuestionIdx += 1
            }
        }
    }
    
    function undoAnswer(){
        // remove current question
        let cQ = document.getElementById("DIV_" + activeQ)
        cQ.classList.add("upcoming")
        setTimeout(function(){
            cQ.remove()
        }, 500)
        
        // if user has already selected an answer for the current question and not submitted it:
        // remove the current answer from 'answers' before proceeding
        if (activeA){
            delete answers[activeQ]
        }

        // get information about the last answered question
        activeQ = Object.keys(answers)[Object.keys(answers).length-1]
        nextQuestionIdx = questionOrder.indexOf(activeQ)
        activeA = null
        let lastAnswer = answers[activeQ]
        delete answers[activeQ]

        let qKey = activeQ
        let aKey = lastAnswer

        let effects = questionInfo[qKey]["antworten"][aKey]["effects"]
        let conditionalEffects = questionInfo[qKey]["antworten"][aKey]["conditionalEffects"]
        
        recent = []
        // calculate score provided by last answer for each code (but this time subtract it!)
        Object.entries(effects).forEach((entry)=>{
            if (Object.keys(activeScenarios).includes(entry[0]) && entry[1] != "FUNC"){
                let scoreVal = +(activeScenarios[entry[0]])
                newScoreVal = scoreVal - entry[1]
                activeScenarios[entry[0]] = newScoreVal
                recent.push(entry[0])
            }
        })

        Object.entries(conditionalEffects).forEach((entry)=>{
            let sKey = entry[0]
            let sEffects = entry[1]
            Object.entries(sEffects).forEach((sEntry)=>{
                let conditions = sEntry[0]
                let score = sEntry[1]
                
                // separate conditions if more than one
                let met = andCheck(conditions)
                if (met){
                    let scoreVal = +(activeScenarios[entry[0]])
                    newScoreVal = scoreVal - score
                    activeScenarios[entry[0]] = newScoreVal
                    recent.push(sKey)
                }
            })
            
        })

        // remove previous question and display it again
        document.getElementById("DIV_" + activeQ).remove()
        displayQuestion(activeQ, from="past")
    }

    function getResult(finalResults){
        // decide which scenarios to show!
        topResults = getTopScenarios(finalResults)
        let firstResult = topResults[0]
        window.open("var_result.html?shownScenario=" + firstResult + "&topTier=" + JSON.stringify(topResults), "_self")
    }

    // Auxiliary funcitons (specialized)
    function getTopScenarios(results){
        shownScenarios = []
        // determine top 3 scores (multiple scenarios can have the same score)
        let firstScore = Math.max(...Object.values(results))
        let topTier = Object.entries(results).filter(([k,v])=>v==firstScore).reduce((r, [k,v])=>[...r,k], []) // returns list of scenarios

        let secondScore = Math.max(...Object.values(Object.entries(results).filter(([k,v])=>v<firstScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let secondTier = Object.entries(results).filter(([k,v])=>v==secondScore).reduce((r, [k,v])=>[...r,k], [])

        let thirdScore = Math.max(...Object.values(Object.entries(results).filter(([k,v])=>v<secondScore).reduce((r, [k, v]) => ({ ...r, [k]: v }), {})))
        let thirdTier = Object.entries(results).filter(([k,v])=>v==thirdScore).reduce((r, [k,v])=>[...r,k], [])
        
        for (let i=0; i<(topTier.length + secondTier.length + thirdTier.length); i++){
            // first tier: include all non-duplicates
            if (i<topTier.length){
                let scenarioToAdd = topTier[i]
                // do not add scenarios with same format hyb, rem, ringonl, etc.
                if (notDuplicate(scenarioToAdd, shownScenarios)){
                    shownScenarios.push(scenarioToAdd)
                }

            } else {
                // second tier: don't consider if score less than zero
                if (i < (topTier.length+secondTier.length) && secondScore>=0){
                    let j = i - topTier.length
                    let scenarioToAdd = secondTier[j]
                    if (notDuplicate(scenarioToAdd, shownScenarios)){
                        shownScenarios.push(scenarioToAdd)
                    }

                } else {
                    // third tier: don't consider if score less than zero
                    if (thirdScore>=0){
                        let k = i - topTier.length - secondTier.length
                        let scenarioToAdd = thirdTier[k]
                        if (notDuplicate(scenarioToAdd, shownScenarios)){
                            shownScenarios.push(scenarioToAdd)
                        }
                    }

                    }
                }
            if (shownScenarios.length >=maxShownAnswers){
                break
            }     
            
        }
        return shownScenarios
    }

    // logic
    function includeCheck(qKey){
        // checks if a question should be displayed
        // assumes that questions have been ordered correctly, otherwise results may be unexpected
        let condition = questionInfo[qKey]["condition"]
        if (condition == true){
            return true
        } else {
            return andCheck(condition)
        }
        
    }

    function andCheck(conditions){
        // checks if all conditions qKey=aKey are simultaneously true
        let i = 0
        while (i < 10){
            [qKey, aKey] = conditions.split("+")[i].split("=")
            if (qKey.includes("!")){
                // check if it's a NOT test
                qKeyR = qKey.split("!")[0]
                if (answers[qKeyR] == aKey | !answers[qKeyR]){
                    return false
                } else {
                    i += 1
                }
            } else {
                if (answers[qKey] != aKey){
                return false
                } else {
                    i += 1
                }
            }

            if (i >= conditions.split("+").length){
                return true
            }
        }
        conditions.split("+").forEach((condition, i)=>{
            [qKey, aKey] = condition.split("=")
            if (answers[qKey] != aKey){
                if (i <4){
                    realConditions[i] = false
                } else {
                    console.log("only up to 4 simultaneous conditions supported; the rest are ignored")
                }
            }
        })
        
    }
    
    function notDuplicate(newScenario, shownScenarios){
        sType = newScenario.split("-")[1]
        if (shownScenarios.map((str)=>str.split("-")[1]).includes(sType)){
            // if the type of scenario is the same, still include if there is asynchronous participation alternative for one scenario
            let matchingScenarios = shownScenarios.filter((str)=>str.split("-")[1] == sType)
            if (matchingScenarios.length > 1){
                // can't add same scenario a third time!
                return false
            }
            let matchingScenario = matchingScenarios[0]
            let asyncNew = newScenario.split("-")[3] // asynchronous participation mode of new scenario
            let asyncMatching = matchingScenario.split("-")[3] // asynchronous participation mode of matching scenario
            if ([asyncNew, asyncMatching].includes("3") && asyncNew != asyncMatching){
                return true
            } else {
                return false
            }
        } else {
            return true
        }
    }


     
</script>
</body>
</html>
