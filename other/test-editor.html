<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Editor.js Demo</title>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/editorjs@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/header@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/list@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/table@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/link@latest"></script>
    <script src="https://cdn.jsdelivr.net/npm/@editorjs/paragraph@latest"></script>
    <style>
        #editorjs {
            border: 1px solid #ccc;
            border-radius: 3px;
            font-family: 'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif;
            padding: 15px;
            border-radius: 8px;
            max-width: 700px;
            margin: 20px auto;
            background: #fff;
        }
    </style>
</head>
<body>
    <h2 style="text-align:center;">My Editor.js Example</h2>
    <!-- Container where Editor.js will appear -->
    <div id="editorjs"></div>
    <button id="saveBtn">Download JSON</button>
    <script>
    // Custom Inline Link Tool with Aria-Label (for accessibility)
    class LinkBreakerTool {
        /**
         * Defines this tool as an Inline Tool.
         */
        static get isInline() {
            return true;
        }

        /**
         * Title for the hover tooltip.
         * @returns {string}
         */
        static get title() {
            return 'Break Link';
        }

        /**
         * A tool that modifies the DOM should not require sanitize rules, 
         * but we define it to ensure no unwanted attributes remain if the original link had them.
         */
        static get sanitize() {
            return {}; // No special rules needed as we are removing the tag.
        }


        /**
         * Determines if the tool's icon should be visible in the Inline Toolbar.
         * This is the function you need to control visibility.
         * @returns {boolean}
         */
        static get isApplicable() {
            console.log('Static Getter: isApplicable() - LinkBreakerTool');
            // Return a function that accepts the selection object and returns true/false
            return (selection) => {
                const api = editor.api; // Access the Editor.js API globally or pass it if possible
                if (!api || !api.selection) {
                    return false;
                }
                
                // Check if the current selection has a parent <a> tag
                const isLink = !!api.selection.findParentTag('A');
                console.log(`  -> isApplicable result: ${isLink}`);
                return isLink;
            };
        }

        /**
         * Custom tag property for finding parent elements.
         */
        constructor({ api }) {
            console.log('Constructor: LinkBreakerTool');
            this.api = api;
            this.tag = 'A';
            this.CSS = {
            button: this.api.styles.inlineToolButton,
            // Use a custom class to change the icon color to red, suggesting 'delete'
            deleteButton: 'cdx-link-breaker-tool--delete' 
            };
        }

        /**
         * Creates the button icon for the inline toolbar.
         * We will use a 'unlink' or 'break' icon.
         * @returns {HTMLElement}
         */
        render() {
            console.log('Function: render() - LinkBreakerTool');
            const button = document.createElement('button');
            button.classList.add(this.CSS.button);
            // Add the delete class for visual cue
            button.classList.add(this.CSS.deleteButton); 
            
            // Icon for breaking a link (e.g., a broken chain or 'x')
            button.innerHTML = this.getToolbarIcon(); 

            return button;
        }

        /**
         * Defines when this tool should be visible.
         * It should only appear if the selected text is part of an existing link.
         * @param {Selection} selection
         * @returns {boolean}
         */
        checkState(selection) {
            console.log('Function: checkState() - LinkBreakerTool');
            // The tool is active/visible only if the current selection is inside an <a> tag.
            // return !!this.api.selection.findParentTag(this.tag);
            return false
        }

        /**
         * This is the function called when the user clicks the icon.
         * It must find the link tag and remove it, then close the toolbar.
         * @param {Range} range - The current selection range (ignored, as we use findParentTag)
         */
        surround(range) {
            console.log('Function: surround() - LinkBreakerTool (Break)');
            const aTag = this.api.selection.findParentTag(this.tag);

            if (aTag) {
            this.unwrap(aTag);
            }
            
            // Close the toolbar immediately after action
            this.api.inlineToolbar.close(); 
        }

        /**
         * Helper function to remove the <a> tag and restore text content.
         * @param {HTMLElement} aTag
         */
        unwrap(aTag) {
            console.log('Function: unwrap() - LinkBreakerTool');
            // 1. Expand selection to cover the entire link tag content
            this.api.selection.expandToTag(aTag);
            const range = window.getSelection().getRangeAt(0);
            
            // 2. Extract the text content
            const text = range.extractContents();
            
            // 3. Remove the tag container
            aTag.remove();
            
            // 4. Insert the text back into the DOM
            range.insertNode(text);
            
            // 5. Restore selection
            this.api.selection.restore();
        }

        /**
         * Icon for the Link Breaker Tool (A simple 'X' or broken chain)
         */
        getToolbarIcon() {
            // This SVG represents a broken chain/unlink symbol
            return `<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12.9 11.1L11.1 12.9" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M11.1 11.1L12.9 12.9" stroke="currentColor" stroke-width="2" stroke-linecap="round"/><path d="M12.986 6.941c1.233 0 2.228 1.006 2.228 2.246 0 1.24-.995 2.246-2.228 2.246H11.09c-.494 0-.895-.406-.895-.905s.401-.905.895-.905h1.896c.247 0 .445-.201.445-.448 0-.247-.198-.448-.445-.448H4.72c-.247 0-.445.201-.445.448 0 .247.198.448.445.448h1.492c.494 0 .895.406.895.905s-.401.905-.895.905H4.72c-1.233 0-2.228-1.006-2.228-2.246 0-1.24.995-2.246 2.228-2.246h8.266zm-5.022 4.965H4.72c-.247 0-.445-.201-.445-.448 0-.247.198-.448.445-.448h3.244c.494 0 .895-.406.895-.905s-.401-.905-.895-.905H4.72c-1.233 0-2.228-1.006-2.228-2.246 0-1.24.995-2.246 2.228-2.246h8.266c1.233 0 2.228 1.006 2.228 2.246 0 1.24-.995 2.246-2.228 2.246h-1.896c-.494 0-.895.406-.895.905s.401.905.895.905h1.896c.247 0 .445.201.445.448 0 .247-.198.448-.445.448H7.964z" fill="none"/></svg>`;
        }
    }
    
    class LinkWithAriaTool {
        /**
         * Static property to specify this is an Inline Tool
         * @returns {boolean}
         */
        static get isInline() {
            return true;
        }

        /**
         * Title for the hover tooltip
         * @returns {string}
         */
        static get title() {
            return 'Link (Aria)';
        }

        /**
         * Sanitizer Rule: Allow <a> tags with specific attributes.
         * NOTE: 'aria-label' must be explicitly whitelisted.
         * @returns {object}
         */
        static get sanitize() {
            return {
            a: {
                href: true,
                'aria-label': true, // <--- IMPORTANT: Allow aria-label attribute
                target: true,
                rel: ['nofollow', 'noopener'],
            },
            };
        }

        /**
         * Class constructor
         * @param {object} param0
         * @param {object} param0.api - Editor.js API
         */
        constructor({ api }) {
            this.api = api;
            this.tag = 'A';
            this.CSS = {
            button: this.api.styles.inlineToolButton,
            input: this.api.styles.input,
            inputShowed: 'ce-inline-tool-input--showed',
            linkWithAriaContainer: 'ce-link-aria-container', // Custom class for the UI container
            };

            // Keep track of the nodes for the URL and aria-label inputs
            this.nodes = {
            container: null,
            urlInput: null,
            ariaLabelInput: null,
            submitButton: null,
            };
        }

        /**
         * Create button for Inline Toolbar.
         * This is the icon the user clicks to open the prompt.
         * @returns {HTMLElement}
         */
        render() {
            console.log("render")
            const button = document.createElement('button');
            button.classList.add(this.CSS.button);
            button.innerHTML = this.getToolbarIcon(); // Custom icon, or use a default one

            return button;
        }

        /**
         * Creates the elements for the URL and aria-label inputs that appear
         * when the tool button is clicked.
         * @returns {HTMLElement}
         */
        renderActions() {
            console.log("renderActions")
            // 1. Create the main container for the inputs
            this.nodes.container = document.createElement('div');
            this.nodes.container.classList.add(this.CSS.linkWithAriaContainer);
            this.nodes.container.classList.add(this.CSS.input);

            // 2. Create the URL input
            this.nodes.urlInput = document.createElement('input');
            this.nodes.urlInput.classList.add(this.CSS.input);
            this.nodes.urlInput.placeholder = 'Enter URL...';
            
            // 3. Create the Aria-Label input
            this.nodes.ariaLabelInput = document.createElement('input');
            this.nodes.ariaLabelInput.classList.add(this.CSS.input);
            this.nodes.ariaLabelInput.placeholder = 'Enter Aria-Label (Optional)';

            // 4. Create a submit button
            this.nodes.submitButton = document.createElement('button');
            this.nodes.submitButton.innerText = 'Apply';
            this.nodes.submitButton.classList.add(this.api.styles.button);
            this.nodes.submitButton.style.marginTop = '10px';
            this.nodes.submitButton.style.display = 'block';
            

            // 5. Add a click handler to the button to apply the style
            this.nodes.submitButton.addEventListener('click', () => {
                this.dataEntered();
            });
            
            // Append elements to the container
            this.nodes.container.appendChild(this.nodes.urlInput);
            this.nodes.container.appendChild(this.nodes.ariaLabelInput);
            this.nodes.container.appendChild(this.nodes.submitButton);
            

            return this.nodes.container;
        }

        /**
         * Called each time the actions panel becomes opened.
         * FIX: This forces focus, preventing the panel from immediately closing.
         */
        onToolbarOpen() {
            console.log("onToolbarOpen")
            // Check if the URL input exists before trying to focus it
            if (this.nodes.urlInput) {
            this.nodes.urlInput.focus();
            }
        }


        /**
         * Callback executed when the Tool is added to the selected text.
         * @param {Range} range - selection range
         */
        surround(range) {
            console.log('Function: surround()');
            if (!range) {
                return;
            }
            
            // Store the range for later use in dataEntered()
            this.currentRange = range;
            console.log('  -> Range stored in this.currentRange (ready to create/edit)');
            
            // NO link-breaking/unwrap logic here anymore.
        }
        
        /**
         * Clean-up function when the toolbar closes
         */
        clear() {
            console.log("clear")
            // Clear the input fields when the tool is closed
            if (this.nodes.urlInput) {
                this.nodes.urlInput.value = '';
            }
            if (this.nodes.ariaLabelInput) {
                this.nodes.ariaLabelInput.value = '';
            }
        }

        /**
         * Check whether the selected text is already a link.
         * @param {Selection} selection
         * @returns {boolean}
         */
        checkState(selection) {
            console.log('Function: checkState()');
            const aTag = this.api.selection.findParentTag(this.tag);
            
            // If a link exists, we need to temporarily store the range for the modification
            if (aTag) {
            try {
                // Get the current range (before inputs are focused)
                const currentSelection = window.getSelection();
                if (currentSelection.rangeCount > 0) {
                    this.currentRange = currentSelection.getRangeAt(0);
                    console.log('  -> Link found. Storing current range for modification.');
                }
            } catch (e) {
                // If accessing selection fails, ignore it, but keep aTag active
            }
            }
            
            // If a link tag is found, populate the input fields for editing
            if (aTag && this.nodes.urlInput) {
            this.nodes.urlInput.value = aTag.href.replace(/^.*:\/\//i, '//') || '';
            this.nodes.ariaLabelInput.value = aTag.getAttribute('aria-label') || '';
            console.log(`  -> Link found. Populating inputs (href: ${aTag.href}).`);
            } else if (this.nodes.urlInput) {
            // Clear inputs if no link is found
            this.nodes.urlInput.value = '';
            this.nodes.ariaLabelInput.value = '';
            console.log('  -> No link found. Clearing inputs.');
            }

            return !!aTag;
        }

        /**
         * Wraps the selected range with an <a> tag.
         * @param {Range} range
         * @param {HTMLElement} wrapper
         */
        wrap(range, wrapper) {
            console.log("wrap")
            range.surroundContents(wrapper);
            this.api.selection.restore();
        }
        
/**
         * Handler for applying the URL and aria-label to the selected link.
         */
        dataEntered() {
            console.log('Function: dataEntered() (Apply button handler)');
            const url = this.nodes.urlInput.value || '';
            const ariaLabel = this.nodes.ariaLabelInput.value || '';
            
            let aTag = this.api.selection.findParentTag(this.tag);
            
            // Define if we are in an editing/creation state where we should proceed
            const isCreatingNewLink = !aTag && url && this.currentRange;
            const isModifyingExistingLink = !!aTag; 
            
            // Proceed if we are creating a new link, or if we are modifying an existing one.
            if (isCreatingNewLink || isModifyingExistingLink) {

                // --- Link Creation/Modification Logic ---
                if (isCreatingNewLink) {
                    // 1. New link: use the stored range to wrap the text
                    aTag = document.createElement(this.tag);
                    this.currentRange.surroundContents(aTag);
                    console.log('  -> New link created and text wrapped.');
                } else {
                    console.log('  -> Existing link being modified.');
                }
                
                // 2. Set Attributes
                if (url) {
                    // Only set/update the href if the URL input is not empty
                    let finalUrl = url.startsWith('http') || url.startsWith('mailto') || url.startsWith('tel') ? url : `https://${url}`;
                    aTag.setAttribute('href', finalUrl);
                    aTag.setAttribute('target', '_blank'); 
                    aTag.setAttribute('rel', 'nofollow noopener'); 
                } else if (isModifyingExistingLink) {
                    // If existing link and user cleared the URL, the link should stay (use the breaker tool to remove)
                    // However, for good UX, if they clear the URL on an *existing* link, we should probably remove it.
                    // Sticking to the requirement: Removal is for the breaker tool. We only modify attributes here.
                    console.log('  -> Existing link edited, URL field cleared. Href attribute unchanged.');
                }

                if (ariaLabel) {
                    aTag.setAttribute('aria-label', ariaLabel);
                } else {
                    aTag.removeAttribute('aria-label');
                }
                
                // 3. Clean up and Close
                this.api.selection.restore(); 
                this.api.inlineToolbar.close(); 
                
            } else {
                // This runs if: !aTag AND (!url OR !this.currentRange)
                // (Attempted new link without URL or valid range)
                console.log('  -> No action taken. Closing toolbar.');
                this.api.inlineToolbar.close(); 
            }
            
            // Clear the stored range regardless of the outcome
            this.currentRange = null; 
        }
        
        /**
         * Helper function to get the link icon (Standard Link icon)
         * @returns {string}
         */
        getToolbarIcon() {
            console.log("getToolbarIcon")
            return `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" fill="none" viewBox="0 0 24 24"><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M7.69998 12.6L7.67896 12.62C6.53993 13.7048 6.52012 15.5155 7.63516 16.625V16.625C8.72293 17.7073 10.4799 17.7102 11.5712 16.6314L13.0263 15.193C14.0703 14.1609 14.2141 12.525 13.3662 11.3266L13.22 11.12"></path><path stroke="currentColor" stroke-linecap="round" stroke-width="2" d="M16.22 11.12L16.3564 10.9805C17.2895 10.0265 17.3478 8.5207 16.4914 7.49733V7.49733C15.5691 6.39509 13.9269 6.25143 12.8271 7.17675L11.3901 8.38588C10.0935 9.47674 9.95706 11.4241 11.0888 12.6852L11.12 12.72"></path></svg>`;
        }
        }


  </script>
    <script>
        fetch('editor-content-test.json')
            .then(response => response.json())
            .then(initialData => {
                const editor = new EditorJS({
                            holder: 'editorjs',
                            autofocus: true,
                            tools: {
                                header: {
                                    class: Header,
                                    inlineToolbar: true,
                                    config: {
                                    levels: [1, 2, 3, 4],
                                    defaultLevel: 2
                                    }
                                },

                                list: {
                                    class: EditorjsList,
                                    inlineToolbar: true
                                },

                                table: {
                                    class: Table,
                                    inlineToolbar: true,
                                    config: {
                                    rows: 2,
                                    cols: 2
                                    }
                                },

                                linkAria: {
                                    class: LinkWithAriaTool,
                                    inlineToolbar: true,
                                },

                                linkBreaker: {
                                    class: LinkBreakerTool,
                                    inlineToolbar: true,
                                },

                                paragraph: {
                                    class: Paragraph,
                                    inlineToolbar: ['linkAria', 'linkBreaker', 'bold', 'italic']
                                },
                                
                                
                            },

                            /** Initial content (optional) */
                            data: initialData,

                            /** Simple configuration */
                            onReady: () => {
                                console.log("Editor.js is ready!");
                            },
                            onChange: () => {
                                console.log("Content changed.");
                            }
                        });

                        document.getElementById('saveBtn').addEventListener('click', async () => {
                            try {
                            const output = await editor.save();          // Get the editor content
                            const json = JSON.stringify(output, null, 2); // Format JSON

                            // Create a downloadable file
                            const blob = new Blob([json], { type: 'application/json' });
                            const url = URL.createObjectURL(blob);

                            const a = document.createElement('a');
                            a.href = url;
                            a.download = 'editor-content.json';          // File name
                            a.click();

                            URL.revokeObjectURL(url);
                            } catch (error) {
                            console.error('Saving failed:', error);
                            }            
                    })
            })
        

      

  </script>
  
</body>
</html>